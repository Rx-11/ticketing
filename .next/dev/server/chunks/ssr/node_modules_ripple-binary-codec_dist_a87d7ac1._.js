module.exports = [
"[project]/node_modules/ripple-binary-codec/dist/enums/definitions.json (json)", ((__turbopack_context__) => {

__turbopack_context__.v(JSON.parse("{\"FIELDS\":[[\"Generic\",{\"isSerialized\":false,\"isSigningField\":false,\"isVLEncoded\":false,\"nth\":0,\"type\":\"Unknown\"}],[\"Invalid\",{\"isSerialized\":false,\"isSigningField\":false,\"isVLEncoded\":false,\"nth\":-1,\"type\":\"Unknown\"}],[\"ObjectEndMarker\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":1,\"type\":\"STObject\"}],[\"ArrayEndMarker\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":1,\"type\":\"STArray\"}],[\"taker_gets_funded\",{\"isSerialized\":false,\"isSigningField\":false,\"isVLEncoded\":false,\"nth\":258,\"type\":\"Amount\"}],[\"taker_pays_funded\",{\"isSerialized\":false,\"isSigningField\":false,\"isVLEncoded\":false,\"nth\":259,\"type\":\"Amount\"}],[\"LedgerEntryType\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":1,\"type\":\"UInt16\"}],[\"TransactionType\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":2,\"type\":\"UInt16\"}],[\"SignerWeight\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":3,\"type\":\"UInt16\"}],[\"TransferFee\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":4,\"type\":\"UInt16\"}],[\"TradingFee\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":5,\"type\":\"UInt16\"}],[\"DiscountedFee\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":6,\"type\":\"UInt16\"}],[\"Version\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":16,\"type\":\"UInt16\"}],[\"HookStateChangeCount\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":17,\"type\":\"UInt16\"}],[\"HookEmitCount\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":18,\"type\":\"UInt16\"}],[\"HookExecutionIndex\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":19,\"type\":\"UInt16\"}],[\"HookApiVersion\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":20,\"type\":\"UInt16\"}],[\"LedgerFixType\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":21,\"type\":\"UInt16\"}],[\"ManagementFeeRate\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":22,\"type\":\"UInt16\"}],[\"NetworkID\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":1,\"type\":\"UInt32\"}],[\"Flags\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":2,\"type\":\"UInt32\"}],[\"SourceTag\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":3,\"type\":\"UInt32\"}],[\"Sequence\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":4,\"type\":\"UInt32\"}],[\"PreviousTxnLgrSeq\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":5,\"type\":\"UInt32\"}],[\"LedgerSequence\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":6,\"type\":\"UInt32\"}],[\"CloseTime\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":7,\"type\":\"UInt32\"}],[\"ParentCloseTime\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":8,\"type\":\"UInt32\"}],[\"SigningTime\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":9,\"type\":\"UInt32\"}],[\"Expiration\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":10,\"type\":\"UInt32\"}],[\"TransferRate\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":11,\"type\":\"UInt32\"}],[\"WalletSize\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":12,\"type\":\"UInt32\"}],[\"OwnerCount\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":13,\"type\":\"UInt32\"}],[\"DestinationTag\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":14,\"type\":\"UInt32\"}],[\"LastUpdateTime\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":15,\"type\":\"UInt32\"}],[\"HighQualityIn\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":16,\"type\":\"UInt32\"}],[\"HighQualityOut\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":17,\"type\":\"UInt32\"}],[\"LowQualityIn\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":18,\"type\":\"UInt32\"}],[\"LowQualityOut\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":19,\"type\":\"UInt32\"}],[\"QualityIn\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":20,\"type\":\"UInt32\"}],[\"QualityOut\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":21,\"type\":\"UInt32\"}],[\"StampEscrow\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":22,\"type\":\"UInt32\"}],[\"BondAmount\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":23,\"type\":\"UInt32\"}],[\"LoadFee\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":24,\"type\":\"UInt32\"}],[\"OfferSequence\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":25,\"type\":\"UInt32\"}],[\"FirstLedgerSequence\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":26,\"type\":\"UInt32\"}],[\"LastLedgerSequence\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":27,\"type\":\"UInt32\"}],[\"TransactionIndex\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":28,\"type\":\"UInt32\"}],[\"OperationLimit\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":29,\"type\":\"UInt32\"}],[\"ReferenceFeeUnits\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":30,\"type\":\"UInt32\"}],[\"ReserveBase\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":31,\"type\":\"UInt32\"}],[\"ReserveIncrement\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":32,\"type\":\"UInt32\"}],[\"SetFlag\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":33,\"type\":\"UInt32\"}],[\"ClearFlag\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":34,\"type\":\"UInt32\"}],[\"SignerQuorum\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":35,\"type\":\"UInt32\"}],[\"CancelAfter\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":36,\"type\":\"UInt32\"}],[\"FinishAfter\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":37,\"type\":\"UInt32\"}],[\"SignerListID\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":38,\"type\":\"UInt32\"}],[\"SettleDelay\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":39,\"type\":\"UInt32\"}],[\"TicketCount\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":40,\"type\":\"UInt32\"}],[\"TicketSequence\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":41,\"type\":\"UInt32\"}],[\"NFTokenTaxon\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":42,\"type\":\"UInt32\"}],[\"MintedNFTokens\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":43,\"type\":\"UInt32\"}],[\"BurnedNFTokens\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":44,\"type\":\"UInt32\"}],[\"HookStateCount\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":45,\"type\":\"UInt32\"}],[\"EmitGeneration\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":46,\"type\":\"UInt32\"}],[\"VoteWeight\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":48,\"type\":\"UInt32\"}],[\"FirstNFTokenSequence\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":50,\"type\":\"UInt32\"}],[\"OracleDocumentID\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":51,\"type\":\"UInt32\"}],[\"PermissionValue\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":52,\"type\":\"UInt32\"}],[\"MutableFlags\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":53,\"type\":\"UInt32\"}],[\"StartDate\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":54,\"type\":\"UInt32\"}],[\"PaymentInterval\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":55,\"type\":\"UInt32\"}],[\"GracePeriod\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":56,\"type\":\"UInt32\"}],[\"PreviousPaymentDate\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":57,\"type\":\"UInt32\"}],[\"NextPaymentDueDate\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":58,\"type\":\"UInt32\"}],[\"PaymentRemaining\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":59,\"type\":\"UInt32\"}],[\"PaymentTotal\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":60,\"type\":\"UInt32\"}],[\"LoanSequence\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":61,\"type\":\"UInt32\"}],[\"CoverRateMinimum\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":62,\"type\":\"UInt32\"}],[\"CoverRateLiquidation\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":63,\"type\":\"UInt32\"}],[\"OverpaymentFee\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":64,\"type\":\"UInt32\"}],[\"InterestRate\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":65,\"type\":\"UInt32\"}],[\"LateInterestRate\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":66,\"type\":\"UInt32\"}],[\"CloseInterestRate\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":67,\"type\":\"UInt32\"}],[\"OverpaymentInterestRate\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":68,\"type\":\"UInt32\"}],[\"IndexNext\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":1,\"type\":\"UInt64\"}],[\"IndexPrevious\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":2,\"type\":\"UInt64\"}],[\"BookNode\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":3,\"type\":\"UInt64\"}],[\"OwnerNode\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":4,\"type\":\"UInt64\"}],[\"BaseFee\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":5,\"type\":\"UInt64\"}],[\"ExchangeRate\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":6,\"type\":\"UInt64\"}],[\"LowNode\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":7,\"type\":\"UInt64\"}],[\"HighNode\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":8,\"type\":\"UInt64\"}],[\"DestinationNode\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":9,\"type\":\"UInt64\"}],[\"Cookie\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":10,\"type\":\"UInt64\"}],[\"ServerVersion\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":11,\"type\":\"UInt64\"}],[\"NFTokenOfferNode\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":12,\"type\":\"UInt64\"}],[\"EmitBurden\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":13,\"type\":\"UInt64\"}],[\"HookOn\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":16,\"type\":\"UInt64\"}],[\"HookInstructionCount\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":17,\"type\":\"UInt64\"}],[\"HookReturnCode\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":18,\"type\":\"UInt64\"}],[\"ReferenceCount\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":19,\"type\":\"UInt64\"}],[\"XChainClaimID\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":20,\"type\":\"UInt64\"}],[\"XChainAccountCreateCount\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":21,\"type\":\"UInt64\"}],[\"XChainAccountClaimCount\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":22,\"type\":\"UInt64\"}],[\"AssetPrice\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":23,\"type\":\"UInt64\"}],[\"MaximumAmount\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":24,\"type\":\"UInt64\"}],[\"OutstandingAmount\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":25,\"type\":\"UInt64\"}],[\"MPTAmount\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":26,\"type\":\"UInt64\"}],[\"IssuerNode\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":27,\"type\":\"UInt64\"}],[\"SubjectNode\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":28,\"type\":\"UInt64\"}],[\"LockedAmount\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":29,\"type\":\"UInt64\"}],[\"VaultNode\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":30,\"type\":\"UInt64\"}],[\"LoanBrokerNode\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":31,\"type\":\"UInt64\"}],[\"EmailHash\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":1,\"type\":\"Hash128\"}],[\"LedgerHash\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":1,\"type\":\"Hash256\"}],[\"ParentHash\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":2,\"type\":\"Hash256\"}],[\"TransactionHash\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":3,\"type\":\"Hash256\"}],[\"AccountHash\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":4,\"type\":\"Hash256\"}],[\"PreviousTxnID\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":5,\"type\":\"Hash256\"}],[\"LedgerIndex\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":6,\"type\":\"Hash256\"}],[\"WalletLocator\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":7,\"type\":\"Hash256\"}],[\"RootIndex\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":8,\"type\":\"Hash256\"}],[\"AccountTxnID\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":9,\"type\":\"Hash256\"}],[\"NFTokenID\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":10,\"type\":\"Hash256\"}],[\"EmitParentTxnID\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":11,\"type\":\"Hash256\"}],[\"EmitNonce\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":12,\"type\":\"Hash256\"}],[\"EmitHookHash\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":13,\"type\":\"Hash256\"}],[\"AMMID\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":14,\"type\":\"Hash256\"}],[\"BookDirectory\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":16,\"type\":\"Hash256\"}],[\"InvoiceID\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":17,\"type\":\"Hash256\"}],[\"Nickname\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":18,\"type\":\"Hash256\"}],[\"Amendment\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":19,\"type\":\"Hash256\"}],[\"Digest\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":21,\"type\":\"Hash256\"}],[\"Channel\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":22,\"type\":\"Hash256\"}],[\"ConsensusHash\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":23,\"type\":\"Hash256\"}],[\"CheckID\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":24,\"type\":\"Hash256\"}],[\"ValidatedHash\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":25,\"type\":\"Hash256\"}],[\"PreviousPageMin\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":26,\"type\":\"Hash256\"}],[\"NextPageMin\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":27,\"type\":\"Hash256\"}],[\"NFTokenBuyOffer\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":28,\"type\":\"Hash256\"}],[\"NFTokenSellOffer\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":29,\"type\":\"Hash256\"}],[\"HookStateKey\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":30,\"type\":\"Hash256\"}],[\"HookHash\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":31,\"type\":\"Hash256\"}],[\"HookNamespace\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":32,\"type\":\"Hash256\"}],[\"HookSetTxnID\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":33,\"type\":\"Hash256\"}],[\"DomainID\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":34,\"type\":\"Hash256\"}],[\"VaultID\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":35,\"type\":\"Hash256\"}],[\"ParentBatchID\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":36,\"type\":\"Hash256\"}],[\"LoanBrokerID\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":37,\"type\":\"Hash256\"}],[\"LoanID\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":38,\"type\":\"Hash256\"}],[\"hash\",{\"isSerialized\":false,\"isSigningField\":false,\"isVLEncoded\":false,\"nth\":257,\"type\":\"Hash256\"}],[\"index\",{\"isSerialized\":false,\"isSigningField\":false,\"isVLEncoded\":false,\"nth\":258,\"type\":\"Hash256\"}],[\"Amount\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":1,\"type\":\"Amount\"}],[\"Balance\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":2,\"type\":\"Amount\"}],[\"LimitAmount\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":3,\"type\":\"Amount\"}],[\"TakerPays\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":4,\"type\":\"Amount\"}],[\"TakerGets\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":5,\"type\":\"Amount\"}],[\"LowLimit\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":6,\"type\":\"Amount\"}],[\"HighLimit\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":7,\"type\":\"Amount\"}],[\"Fee\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":8,\"type\":\"Amount\"}],[\"SendMax\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":9,\"type\":\"Amount\"}],[\"DeliverMin\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":10,\"type\":\"Amount\"}],[\"Amount2\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":11,\"type\":\"Amount\"}],[\"BidMin\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":12,\"type\":\"Amount\"}],[\"BidMax\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":13,\"type\":\"Amount\"}],[\"MinimumOffer\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":16,\"type\":\"Amount\"}],[\"RippleEscrow\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":17,\"type\":\"Amount\"}],[\"DeliveredAmount\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":18,\"type\":\"Amount\"}],[\"NFTokenBrokerFee\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":19,\"type\":\"Amount\"}],[\"BaseFeeDrops\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":22,\"type\":\"Amount\"}],[\"ReserveBaseDrops\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":23,\"type\":\"Amount\"}],[\"ReserveIncrementDrops\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":24,\"type\":\"Amount\"}],[\"LPTokenOut\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":25,\"type\":\"Amount\"}],[\"LPTokenIn\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":26,\"type\":\"Amount\"}],[\"EPrice\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":27,\"type\":\"Amount\"}],[\"Price\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":28,\"type\":\"Amount\"}],[\"SignatureReward\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":29,\"type\":\"Amount\"}],[\"MinAccountCreateAmount\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":30,\"type\":\"Amount\"}],[\"LPTokenBalance\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":31,\"type\":\"Amount\"}],[\"PublicKey\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":true,\"nth\":1,\"type\":\"Blob\"}],[\"MessageKey\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":true,\"nth\":2,\"type\":\"Blob\"}],[\"SigningPubKey\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":true,\"nth\":3,\"type\":\"Blob\"}],[\"TxnSignature\",{\"isSerialized\":true,\"isSigningField\":false,\"isVLEncoded\":true,\"nth\":4,\"type\":\"Blob\"}],[\"URI\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":true,\"nth\":5,\"type\":\"Blob\"}],[\"Signature\",{\"isSerialized\":true,\"isSigningField\":false,\"isVLEncoded\":true,\"nth\":6,\"type\":\"Blob\"}],[\"Domain\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":true,\"nth\":7,\"type\":\"Blob\"}],[\"FundCode\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":true,\"nth\":8,\"type\":\"Blob\"}],[\"RemoveCode\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":true,\"nth\":9,\"type\":\"Blob\"}],[\"ExpireCode\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":true,\"nth\":10,\"type\":\"Blob\"}],[\"CreateCode\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":true,\"nth\":11,\"type\":\"Blob\"}],[\"MemoType\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":true,\"nth\":12,\"type\":\"Blob\"}],[\"MemoData\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":true,\"nth\":13,\"type\":\"Blob\"}],[\"MemoFormat\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":true,\"nth\":14,\"type\":\"Blob\"}],[\"Fulfillment\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":true,\"nth\":16,\"type\":\"Blob\"}],[\"Condition\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":true,\"nth\":17,\"type\":\"Blob\"}],[\"MasterSignature\",{\"isSerialized\":true,\"isSigningField\":false,\"isVLEncoded\":true,\"nth\":18,\"type\":\"Blob\"}],[\"UNLModifyValidator\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":true,\"nth\":19,\"type\":\"Blob\"}],[\"ValidatorToDisable\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":true,\"nth\":20,\"type\":\"Blob\"}],[\"ValidatorToReEnable\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":true,\"nth\":21,\"type\":\"Blob\"}],[\"HookStateData\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":true,\"nth\":22,\"type\":\"Blob\"}],[\"HookReturnString\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":true,\"nth\":23,\"type\":\"Blob\"}],[\"HookParameterName\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":true,\"nth\":24,\"type\":\"Blob\"}],[\"HookParameterValue\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":true,\"nth\":25,\"type\":\"Blob\"}],[\"DIDDocument\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":true,\"nth\":26,\"type\":\"Blob\"}],[\"Data\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":true,\"nth\":27,\"type\":\"Blob\"}],[\"AssetClass\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":true,\"nth\":28,\"type\":\"Blob\"}],[\"Provider\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":true,\"nth\":29,\"type\":\"Blob\"}],[\"MPTokenMetadata\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":true,\"nth\":30,\"type\":\"Blob\"}],[\"CredentialType\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":true,\"nth\":31,\"type\":\"Blob\"}],[\"Account\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":true,\"nth\":1,\"type\":\"AccountID\"}],[\"Owner\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":true,\"nth\":2,\"type\":\"AccountID\"}],[\"Destination\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":true,\"nth\":3,\"type\":\"AccountID\"}],[\"Issuer\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":true,\"nth\":4,\"type\":\"AccountID\"}],[\"Authorize\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":true,\"nth\":5,\"type\":\"AccountID\"}],[\"Unauthorize\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":true,\"nth\":6,\"type\":\"AccountID\"}],[\"RegularKey\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":true,\"nth\":8,\"type\":\"AccountID\"}],[\"NFTokenMinter\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":true,\"nth\":9,\"type\":\"AccountID\"}],[\"EmitCallback\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":true,\"nth\":10,\"type\":\"AccountID\"}],[\"Holder\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":true,\"nth\":11,\"type\":\"AccountID\"}],[\"Delegate\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":true,\"nth\":12,\"type\":\"AccountID\"}],[\"HookAccount\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":true,\"nth\":16,\"type\":\"AccountID\"}],[\"OtherChainSource\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":true,\"nth\":18,\"type\":\"AccountID\"}],[\"OtherChainDestination\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":true,\"nth\":19,\"type\":\"AccountID\"}],[\"AttestationSignerAccount\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":true,\"nth\":20,\"type\":\"AccountID\"}],[\"AttestationRewardAccount\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":true,\"nth\":21,\"type\":\"AccountID\"}],[\"LockingChainDoor\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":true,\"nth\":22,\"type\":\"AccountID\"}],[\"IssuingChainDoor\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":true,\"nth\":23,\"type\":\"AccountID\"}],[\"Subject\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":true,\"nth\":24,\"type\":\"AccountID\"}],[\"Borrower\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":true,\"nth\":25,\"type\":\"AccountID\"}],[\"Counterparty\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":true,\"nth\":26,\"type\":\"AccountID\"}],[\"Number\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":1,\"type\":\"Number\"}],[\"AssetsAvailable\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":2,\"type\":\"Number\"}],[\"AssetsMaximum\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":3,\"type\":\"Number\"}],[\"AssetsTotal\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":4,\"type\":\"Number\"}],[\"LossUnrealized\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":5,\"type\":\"Number\"}],[\"DebtTotal\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":6,\"type\":\"Number\"}],[\"DebtMaximum\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":7,\"type\":\"Number\"}],[\"CoverAvailable\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":8,\"type\":\"Number\"}],[\"LoanOriginationFee\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":9,\"type\":\"Number\"}],[\"LoanServiceFee\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":10,\"type\":\"Number\"}],[\"LatePaymentFee\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":11,\"type\":\"Number\"}],[\"ClosePaymentFee\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":12,\"type\":\"Number\"}],[\"PrincipalOutstanding\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":13,\"type\":\"Number\"}],[\"PrincipalRequested\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":14,\"type\":\"Number\"}],[\"TotalValueOutstanding\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":15,\"type\":\"Number\"}],[\"PeriodicPayment\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":16,\"type\":\"Number\"}],[\"ManagementFeeOutstanding\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":17,\"type\":\"Number\"}],[\"LoanScale\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":1,\"type\":\"Int32\"}],[\"TransactionMetaData\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":2,\"type\":\"STObject\"}],[\"CreatedNode\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":3,\"type\":\"STObject\"}],[\"DeletedNode\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":4,\"type\":\"STObject\"}],[\"ModifiedNode\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":5,\"type\":\"STObject\"}],[\"PreviousFields\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":6,\"type\":\"STObject\"}],[\"FinalFields\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":7,\"type\":\"STObject\"}],[\"NewFields\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":8,\"type\":\"STObject\"}],[\"TemplateEntry\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":9,\"type\":\"STObject\"}],[\"Memo\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":10,\"type\":\"STObject\"}],[\"SignerEntry\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":11,\"type\":\"STObject\"}],[\"NFToken\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":12,\"type\":\"STObject\"}],[\"EmitDetails\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":13,\"type\":\"STObject\"}],[\"Hook\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":14,\"type\":\"STObject\"}],[\"Permission\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":15,\"type\":\"STObject\"}],[\"Signer\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":16,\"type\":\"STObject\"}],[\"Majority\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":18,\"type\":\"STObject\"}],[\"DisabledValidator\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":19,\"type\":\"STObject\"}],[\"EmittedTxn\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":20,\"type\":\"STObject\"}],[\"HookExecution\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":21,\"type\":\"STObject\"}],[\"HookDefinition\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":22,\"type\":\"STObject\"}],[\"HookParameter\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":23,\"type\":\"STObject\"}],[\"HookGrant\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":24,\"type\":\"STObject\"}],[\"VoteEntry\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":25,\"type\":\"STObject\"}],[\"AuctionSlot\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":26,\"type\":\"STObject\"}],[\"AuthAccount\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":27,\"type\":\"STObject\"}],[\"XChainClaimProofSig\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":28,\"type\":\"STObject\"}],[\"XChainCreateAccountProofSig\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":29,\"type\":\"STObject\"}],[\"XChainClaimAttestationCollectionElement\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":30,\"type\":\"STObject\"}],[\"XChainCreateAccountAttestationCollectionElement\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":31,\"type\":\"STObject\"}],[\"PriceData\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":32,\"type\":\"STObject\"}],[\"Credential\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":33,\"type\":\"STObject\"}],[\"RawTransaction\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":34,\"type\":\"STObject\"}],[\"BatchSigner\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":35,\"type\":\"STObject\"}],[\"Book\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":36,\"type\":\"STObject\"}],[\"CounterpartySignature\",{\"isSerialized\":true,\"isSigningField\":false,\"isVLEncoded\":false,\"nth\":37,\"type\":\"STObject\"}],[\"Signers\",{\"isSerialized\":true,\"isSigningField\":false,\"isVLEncoded\":false,\"nth\":3,\"type\":\"STArray\"}],[\"SignerEntries\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":4,\"type\":\"STArray\"}],[\"Template\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":5,\"type\":\"STArray\"}],[\"Necessary\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":6,\"type\":\"STArray\"}],[\"Sufficient\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":7,\"type\":\"STArray\"}],[\"AffectedNodes\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":8,\"type\":\"STArray\"}],[\"Memos\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":9,\"type\":\"STArray\"}],[\"NFTokens\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":10,\"type\":\"STArray\"}],[\"Hooks\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":11,\"type\":\"STArray\"}],[\"VoteSlots\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":12,\"type\":\"STArray\"}],[\"AdditionalBooks\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":13,\"type\":\"STArray\"}],[\"Majorities\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":16,\"type\":\"STArray\"}],[\"DisabledValidators\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":17,\"type\":\"STArray\"}],[\"HookExecutions\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":18,\"type\":\"STArray\"}],[\"HookParameters\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":19,\"type\":\"STArray\"}],[\"HookGrants\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":20,\"type\":\"STArray\"}],[\"XChainClaimAttestations\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":21,\"type\":\"STArray\"}],[\"XChainCreateAccountAttestations\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":22,\"type\":\"STArray\"}],[\"PriceDataSeries\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":24,\"type\":\"STArray\"}],[\"AuthAccounts\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":25,\"type\":\"STArray\"}],[\"AuthorizeCredentials\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":26,\"type\":\"STArray\"}],[\"UnauthorizeCredentials\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":27,\"type\":\"STArray\"}],[\"AcceptedCredentials\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":28,\"type\":\"STArray\"}],[\"Permissions\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":29,\"type\":\"STArray\"}],[\"RawTransactions\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":30,\"type\":\"STArray\"}],[\"BatchSigners\",{\"isSerialized\":true,\"isSigningField\":false,\"isVLEncoded\":false,\"nth\":31,\"type\":\"STArray\"}],[\"CloseResolution\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":1,\"type\":\"UInt8\"}],[\"Method\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":2,\"type\":\"UInt8\"}],[\"TransactionResult\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":3,\"type\":\"UInt8\"}],[\"Scale\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":4,\"type\":\"UInt8\"}],[\"AssetScale\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":5,\"type\":\"UInt8\"}],[\"TickSize\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":16,\"type\":\"UInt8\"}],[\"UNLModifyDisabling\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":17,\"type\":\"UInt8\"}],[\"HookResult\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":18,\"type\":\"UInt8\"}],[\"WasLockingChainSend\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":19,\"type\":\"UInt8\"}],[\"WithdrawalPolicy\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":20,\"type\":\"UInt8\"}],[\"TakerPaysCurrency\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":1,\"type\":\"Hash160\"}],[\"TakerPaysIssuer\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":2,\"type\":\"Hash160\"}],[\"TakerGetsCurrency\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":3,\"type\":\"Hash160\"}],[\"TakerGetsIssuer\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":4,\"type\":\"Hash160\"}],[\"Paths\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":1,\"type\":\"PathSet\"}],[\"Indexes\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":true,\"nth\":1,\"type\":\"Vector256\"}],[\"Hashes\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":true,\"nth\":2,\"type\":\"Vector256\"}],[\"Amendments\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":true,\"nth\":3,\"type\":\"Vector256\"}],[\"NFTokenOffers\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":true,\"nth\":4,\"type\":\"Vector256\"}],[\"CredentialIDs\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":true,\"nth\":5,\"type\":\"Vector256\"}],[\"MPTokenIssuanceID\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":1,\"type\":\"Hash192\"}],[\"ShareMPTID\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":2,\"type\":\"Hash192\"}],[\"LockingChainIssue\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":1,\"type\":\"Issue\"}],[\"IssuingChainIssue\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":2,\"type\":\"Issue\"}],[\"Asset\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":3,\"type\":\"Issue\"}],[\"Asset2\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":4,\"type\":\"Issue\"}],[\"XChainBridge\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":1,\"type\":\"XChainBridge\"}],[\"BaseAsset\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":1,\"type\":\"Currency\"}],[\"QuoteAsset\",{\"isSerialized\":true,\"isSigningField\":true,\"isVLEncoded\":false,\"nth\":2,\"type\":\"Currency\"}],[\"Transaction\",{\"isSerialized\":false,\"isSigningField\":false,\"isVLEncoded\":false,\"nth\":257,\"type\":\"Transaction\"}],[\"LedgerEntry\",{\"isSerialized\":false,\"isSigningField\":false,\"isVLEncoded\":false,\"nth\":257,\"type\":\"LedgerEntry\"}],[\"Validation\",{\"isSerialized\":false,\"isSigningField\":false,\"isVLEncoded\":false,\"nth\":257,\"type\":\"Validation\"}],[\"Metadata\",{\"isSerialized\":false,\"isSigningField\":false,\"isVLEncoded\":false,\"nth\":257,\"type\":\"Metadata\"}]],\"LEDGER_ENTRY_TYPES\":{\"AMM\":121,\"AccountRoot\":97,\"Amendments\":102,\"Bridge\":105,\"Check\":67,\"Credential\":129,\"DID\":73,\"Delegate\":131,\"DepositPreauth\":112,\"DirectoryNode\":100,\"Escrow\":117,\"FeeSettings\":115,\"Invalid\":-1,\"LedgerHashes\":104,\"Loan\":137,\"LoanBroker\":136,\"MPToken\":127,\"MPTokenIssuance\":126,\"NFTokenOffer\":55,\"NFTokenPage\":80,\"NegativeUNL\":78,\"Offer\":111,\"Oracle\":128,\"PayChannel\":120,\"PermissionedDomain\":130,\"RippleState\":114,\"SignerList\":83,\"Ticket\":84,\"Vault\":132,\"XChainOwnedClaimID\":113,\"XChainOwnedCreateAccountClaimID\":116},\"TRANSACTION_RESULTS\":{\"tecAMM_ACCOUNT\":168,\"tecAMM_BALANCE\":163,\"tecAMM_EMPTY\":166,\"tecAMM_FAILED\":164,\"tecAMM_INVALID_TOKENS\":165,\"tecAMM_NOT_EMPTY\":167,\"tecARRAY_EMPTY\":190,\"tecARRAY_TOO_LARGE\":191,\"tecBAD_CREDENTIALS\":193,\"tecCANT_ACCEPT_OWN_NFTOKEN_OFFER\":158,\"tecCLAIM\":100,\"tecCRYPTOCONDITION_ERROR\":146,\"tecDIR_FULL\":121,\"tecDST_TAG_NEEDED\":143,\"tecDUPLICATE\":149,\"tecEMPTY_DID\":187,\"tecEXPIRED\":148,\"tecFAILED_PROCESSING\":105,\"tecFROZEN\":137,\"tecHAS_OBLIGATIONS\":151,\"tecHOOK_REJECTED\":153,\"tecINCOMPLETE\":169,\"tecINSUFFICIENT_FUNDS\":159,\"tecINSUFFICIENT_PAYMENT\":161,\"tecINSUFFICIENT_RESERVE\":141,\"tecINSUFF_FEE\":136,\"tecINSUF_RESERVE_LINE\":122,\"tecINSUF_RESERVE_OFFER\":123,\"tecINTERNAL\":144,\"tecINVALID_UPDATE_TIME\":188,\"tecINVARIANT_FAILED\":147,\"tecKILLED\":150,\"tecLIMIT_EXCEEDED\":195,\"tecLOCKED\":192,\"tecMAX_SEQUENCE_REACHED\":154,\"tecNEED_MASTER_KEY\":142,\"tecNFTOKEN_BUY_SELL_MISMATCH\":156,\"tecNFTOKEN_OFFER_TYPE_MISMATCH\":157,\"tecNO_ALTERNATIVE_KEY\":130,\"tecNO_AUTH\":134,\"tecNO_DELEGATE_PERMISSION\":198,\"tecNO_DST\":124,\"tecNO_DST_INSUF_XRP\":125,\"tecNO_ENTRY\":140,\"tecNO_ISSUER\":133,\"tecNO_LINE\":135,\"tecNO_LINE_INSUF_RESERVE\":126,\"tecNO_LINE_REDUNDANT\":127,\"tecNO_PERMISSION\":139,\"tecNO_REGULAR_KEY\":131,\"tecNO_SUITABLE_NFTOKEN_PAGE\":155,\"tecNO_TARGET\":138,\"tecOBJECT_NOT_FOUND\":160,\"tecOVERSIZE\":145,\"tecOWNERS\":132,\"tecPATH_DRY\":128,\"tecPATH_PARTIAL\":101,\"tecPRECISION_LOSS\":197,\"tecPSEUDO_ACCOUNT\":196,\"tecTOKEN_PAIR_NOT_FOUND\":189,\"tecTOO_SOON\":152,\"tecUNFUNDED\":129,\"tecUNFUNDED_ADD\":102,\"tecUNFUNDED_AMM\":162,\"tecUNFUNDED_OFFER\":103,\"tecUNFUNDED_PAYMENT\":104,\"tecWRONG_ASSET\":194,\"tecXCHAIN_ACCOUNT_CREATE_PAST\":181,\"tecXCHAIN_ACCOUNT_CREATE_TOO_MANY\":182,\"tecXCHAIN_BAD_CLAIM_ID\":172,\"tecXCHAIN_BAD_PUBLIC_KEY_ACCOUNT_PAIR\":185,\"tecXCHAIN_BAD_TRANSFER_ISSUE\":170,\"tecXCHAIN_CLAIM_NO_QUORUM\":173,\"tecXCHAIN_CREATE_ACCOUNT_DISABLED\":186,\"tecXCHAIN_CREATE_ACCOUNT_NONXRP_ISSUE\":175,\"tecXCHAIN_INSUFF_CREATE_AMOUNT\":180,\"tecXCHAIN_NO_CLAIM_ID\":171,\"tecXCHAIN_NO_SIGNERS_LIST\":178,\"tecXCHAIN_PAYMENT_FAILED\":183,\"tecXCHAIN_PROOF_UNKNOWN_KEY\":174,\"tecXCHAIN_REWARD_MISMATCH\":177,\"tecXCHAIN_SELF_COMMIT\":184,\"tecXCHAIN_SENDING_ACCOUNT_MISMATCH\":179,\"tecXCHAIN_WRONG_CHAIN\":176,\"tefALREADY\":-198,\"tefBAD_ADD_AUTH\":-197,\"tefBAD_AUTH\":-196,\"tefBAD_AUTH_MASTER\":-183,\"tefBAD_LEDGER\":-195,\"tefBAD_QUORUM\":-185,\"tefBAD_SIGNATURE\":-186,\"tefCREATED\":-194,\"tefEXCEPTION\":-193,\"tefFAILURE\":-199,\"tefINTERNAL\":-192,\"tefINVALID_LEDGER_FIX_TYPE\":-178,\"tefINVARIANT_FAILED\":-182,\"tefMASTER_DISABLED\":-188,\"tefMAX_LEDGER\":-187,\"tefNFTOKEN_IS_NOT_TRANSFERABLE\":-179,\"tefNOT_MULTI_SIGNING\":-184,\"tefNO_AUTH_REQUIRED\":-191,\"tefNO_TICKET\":-180,\"tefPAST_SEQ\":-190,\"tefTOO_BIG\":-181,\"tefWRONG_PRIOR\":-189,\"telBAD_DOMAIN\":-398,\"telBAD_PATH_COUNT\":-397,\"telBAD_PUBLIC_KEY\":-396,\"telCAN_NOT_QUEUE\":-392,\"telCAN_NOT_QUEUE_BALANCE\":-391,\"telCAN_NOT_QUEUE_BLOCKED\":-389,\"telCAN_NOT_QUEUE_BLOCKS\":-390,\"telCAN_NOT_QUEUE_FEE\":-388,\"telCAN_NOT_QUEUE_FULL\":-387,\"telENV_RPC_FAILED\":-383,\"telFAILED_PROCESSING\":-395,\"telINSUF_FEE_P\":-394,\"telLOCAL_ERROR\":-399,\"telNETWORK_ID_MAKES_TX_NON_CANONICAL\":-384,\"telNO_DST_PARTIAL\":-393,\"telREQUIRES_NETWORK_ID\":-385,\"telWRONG_NETWORK\":-386,\"temARRAY_EMPTY\":-253,\"temARRAY_TOO_LARGE\":-252,\"temBAD_AMM_TOKENS\":-261,\"temBAD_AMOUNT\":-298,\"temBAD_CURRENCY\":-297,\"temBAD_EXPIRATION\":-296,\"temBAD_FEE\":-295,\"temBAD_ISSUER\":-294,\"temBAD_LIMIT\":-293,\"temBAD_NFTOKEN_TRANSFER_FEE\":-262,\"temBAD_OFFER\":-292,\"temBAD_PATH\":-291,\"temBAD_PATH_LOOP\":-290,\"temBAD_QUORUM\":-271,\"temBAD_REGKEY\":-289,\"temBAD_SEND_XRP_LIMIT\":-288,\"temBAD_SEND_XRP_MAX\":-287,\"temBAD_SEND_XRP_NO_DIRECT\":-286,\"temBAD_SEND_XRP_PARTIAL\":-285,\"temBAD_SEND_XRP_PATHS\":-284,\"temBAD_SEQUENCE\":-283,\"temBAD_SIGNATURE\":-282,\"temBAD_SIGNER\":-272,\"temBAD_SRC_ACCOUNT\":-281,\"temBAD_TICK_SIZE\":-269,\"temBAD_TRANSFER_FEE\":-251,\"temBAD_TRANSFER_RATE\":-280,\"temBAD_WEIGHT\":-270,\"temCANNOT_PREAUTH_SELF\":-267,\"temDISABLED\":-273,\"temDST_IS_SRC\":-279,\"temDST_NEEDED\":-278,\"temEMPTY_DID\":-254,\"temINVALID\":-277,\"temINVALID_ACCOUNT_ID\":-268,\"temINVALID_COUNT\":-266,\"temINVALID_FLAG\":-276,\"temINVALID_INNER_BATCH\":-250,\"temMALFORMED\":-299,\"temREDUNDANT\":-275,\"temRIPPLE_EMPTY\":-274,\"temSEQ_AND_TICKET\":-263,\"temUNCERTAIN\":-265,\"temUNKNOWN\":-264,\"temXCHAIN_BAD_PROOF\":-259,\"temXCHAIN_BRIDGE_BAD_ISSUES\":-258,\"temXCHAIN_BRIDGE_BAD_MIN_ACCOUNT_CREATE_AMOUNT\":-256,\"temXCHAIN_BRIDGE_BAD_REWARD_AMOUNT\":-255,\"temXCHAIN_BRIDGE_NONDOOR_OWNER\":-257,\"temXCHAIN_EQUAL_DOOR_ACCOUNTS\":-260,\"terADDRESS_COLLISION\":-86,\"terFUNDS_SPENT\":-98,\"terINSUF_FEE_B\":-97,\"terLAST\":-91,\"terNO_ACCOUNT\":-96,\"terNO_AMM\":-87,\"terNO_AUTH\":-95,\"terNO_DELEGATE_PERMISSION\":-85,\"terNO_LINE\":-94,\"terNO_RIPPLE\":-90,\"terOWNERS\":-93,\"terPRE_SEQ\":-92,\"terPRE_TICKET\":-88,\"terQUEUED\":-89,\"terRETRY\":-99,\"tesSUCCESS\":0},\"TRANSACTION_TYPES\":{\"AMMBid\":39,\"AMMClawback\":31,\"AMMCreate\":35,\"AMMDelete\":40,\"AMMDeposit\":36,\"AMMVote\":38,\"AMMWithdraw\":37,\"AccountDelete\":21,\"AccountSet\":3,\"Batch\":71,\"CheckCancel\":18,\"CheckCash\":17,\"CheckCreate\":16,\"Clawback\":30,\"CredentialAccept\":59,\"CredentialCreate\":58,\"CredentialDelete\":60,\"DIDDelete\":50,\"DIDSet\":49,\"DelegateSet\":64,\"DepositPreauth\":19,\"EnableAmendment\":100,\"EscrowCancel\":4,\"EscrowCreate\":1,\"EscrowFinish\":2,\"Invalid\":-1,\"LedgerStateFix\":53,\"LoanBrokerCoverClawback\":78,\"LoanBrokerCoverDeposit\":76,\"LoanBrokerCoverWithdraw\":77,\"LoanBrokerDelete\":75,\"LoanBrokerSet\":74,\"LoanDelete\":81,\"LoanManage\":82,\"LoanPay\":84,\"LoanSet\":80,\"MPTokenAuthorize\":57,\"MPTokenIssuanceCreate\":54,\"MPTokenIssuanceDestroy\":55,\"MPTokenIssuanceSet\":56,\"NFTokenAcceptOffer\":29,\"NFTokenBurn\":26,\"NFTokenCancelOffer\":28,\"NFTokenCreateOffer\":27,\"NFTokenMint\":25,\"NFTokenModify\":61,\"OfferCancel\":8,\"OfferCreate\":7,\"OracleDelete\":52,\"OracleSet\":51,\"Payment\":0,\"PaymentChannelClaim\":15,\"PaymentChannelCreate\":13,\"PaymentChannelFund\":14,\"PermissionedDomainDelete\":63,\"PermissionedDomainSet\":62,\"SetFee\":101,\"SetRegularKey\":5,\"SignerListSet\":12,\"TicketCreate\":10,\"TrustSet\":20,\"UNLModify\":102,\"VaultClawback\":70,\"VaultCreate\":65,\"VaultDelete\":67,\"VaultDeposit\":68,\"VaultSet\":66,\"VaultWithdraw\":69,\"XChainAccountCreateCommit\":44,\"XChainAddAccountCreateAttestation\":46,\"XChainAddClaimAttestation\":45,\"XChainClaim\":43,\"XChainCommit\":42,\"XChainCreateBridge\":48,\"XChainCreateClaimID\":41,\"XChainModifyBridge\":47},\"TYPES\":{\"AccountID\":8,\"Amount\":6,\"Blob\":7,\"Currency\":26,\"Done\":-1,\"Hash128\":4,\"Hash160\":17,\"Hash192\":21,\"Hash256\":5,\"Int32\":10,\"Int64\":11,\"Issue\":24,\"LedgerEntry\":10002,\"Metadata\":10004,\"NotPresent\":0,\"Number\":9,\"PathSet\":18,\"STArray\":15,\"STObject\":14,\"Transaction\":10001,\"UInt16\":1,\"UInt32\":2,\"UInt384\":22,\"UInt512\":23,\"UInt64\":3,\"UInt8\":16,\"UInt96\":20,\"Unknown\":-2,\"Validation\":10003,\"Vector256\":19,\"XChainBridge\":25}}"));}),
"[project]/node_modules/ripple-binary-codec/dist/enums/bytes.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BytesLookup = exports.Bytes = void 0;
/*
 * @brief: Bytes, name, and ordinal representing one type, ledger_type, transaction type, or result
 */ class Bytes {
    constructor(name, ordinal, ordinalWidth){
        this.name = name;
        this.ordinal = ordinal;
        this.ordinalWidth = ordinalWidth;
        this.bytes = new Uint8Array(ordinalWidth);
        for(let i = 0; i < ordinalWidth; i++){
            this.bytes[ordinalWidth - i - 1] = ordinal >>> i * 8 & 0xff;
        }
    }
    toJSON() {
        return this.name;
    }
    toBytesSink(sink) {
        sink.put(this.bytes);
    }
    toBytes() {
        return this.bytes;
    }
}
exports.Bytes = Bytes;
/*
 * @brief: Collection of Bytes objects, mapping bidirectionally
 */ class BytesLookup {
    constructor(types, ordinalWidth){
        this.ordinalWidth = ordinalWidth;
        Object.entries(types).forEach(([k, v])=>{
            this.add(k, v);
        });
    }
    /**
     * Add a new name value pair to the BytesLookup.
     *
     * @param name - A human readable name for the field.
     * @param value - The numeric value for the field.
     * @throws if the name or value already exist in the lookup because it's unclear how to decode.
     */ add(name, value) {
        if (this[name]) {
            throw new SyntaxError(`Attempted to add a value with a duplicate name "${name}". This is not allowed because it is unclear how to decode.`);
        }
        if (this[value.toString()]) {
            throw new SyntaxError(`Attempted to add a duplicate value under a different name (Given name: "${name}" and previous name: "${this[value.toString()]}. This is not allowed because it is unclear how to decode.\nGiven value: ${value.toString()}`);
        }
        this[name] = new Bytes(name, value, this.ordinalWidth);
        this[value.toString()] = this[name];
    }
    from(value) {
        return value instanceof Bytes ? value : this[value];
    }
    fromParser(parser) {
        return this.from(parser.readUIntN(this.ordinalWidth).toString());
    }
}
exports.BytesLookup = BytesLookup; //# sourceMappingURL=bytes.js.map
}),
"[project]/node_modules/ripple-binary-codec/dist/serdes/binary-serializer.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BinarySerializer = exports.BytesList = void 0;
const utils_1 = __turbopack_context__.r("[project]/node_modules/@xrplf/isomorphic/dist/utils/index.js [app-ssr] (ecmascript)");
/**
 * Bytes list is a collection of Uint8Array objects
 */ class BytesList {
    constructor(){
        this.bytesArray = [];
    }
    /**
     * Get the total number of bytes in the BytesList
     *
     * @return the number of bytes
     */ getLength() {
        return (0, utils_1.concat)(this.bytesArray).byteLength;
    }
    /**
     * Put bytes in the BytesList
     *
     * @param bytesArg A Uint8Array
     * @return this BytesList
     */ put(bytesArg) {
        const bytes = Uint8Array.from(bytesArg); // Temporary, to catch instances of Uint8Array being passed in
        this.bytesArray.push(bytes);
        return this;
    }
    /**
     * Write this BytesList to the back of another bytes list
     *
     *  @param list The BytesList to write to
     */ toBytesSink(list) {
        list.put(this.toBytes());
    }
    toBytes() {
        return (0, utils_1.concat)(this.bytesArray);
    }
    toHex() {
        return (0, utils_1.bytesToHex)(this.toBytes());
    }
}
exports.BytesList = BytesList;
/**
 * BinarySerializer is used to write fields and values to Uint8Arrays
 */ class BinarySerializer {
    constructor(sink){
        this.sink = new BytesList();
        this.sink = sink;
    }
    /**
     * Write a value to this BinarySerializer
     *
     * @param value a SerializedType value
     */ write(value) {
        value.toBytesSink(this.sink);
    }
    /**
     * Write bytes to this BinarySerializer
     *
     * @param bytes the bytes to write
     */ put(bytes) {
        this.sink.put(bytes);
    }
    /**
     * Write a value of a given type to this BinarySerializer
     *
     * @param type the type to write
     * @param value a value of that type
     */ writeType(type, value) {
        this.write(type.from(value));
    }
    /**
     * Write BytesList to this BinarySerializer
     *
     * @param bl BytesList to write to BinarySerializer
     */ writeBytesList(bl) {
        bl.toBytesSink(this.sink);
    }
    /**
     * Calculate the header of Variable Length encoded bytes
     *
     * @param length the length of the bytes
     */ encodeVariableLength(length) {
        const lenBytes = new Uint8Array(3);
        if (length <= 192) {
            lenBytes[0] = length;
            return lenBytes.slice(0, 1);
        } else if (length <= 12480) {
            length -= 193;
            lenBytes[0] = 193 + (length >>> 8);
            lenBytes[1] = length & 0xff;
            return lenBytes.slice(0, 2);
        } else if (length <= 918744) {
            length -= 12481;
            lenBytes[0] = 241 + (length >>> 16);
            lenBytes[1] = length >> 8 & 0xff;
            lenBytes[2] = length & 0xff;
            return lenBytes.slice(0, 3);
        }
        throw new Error('Overflow error');
    }
    /**
     * Write field and value to BinarySerializer
     *
     * @param field field to write to BinarySerializer
     * @param value value to write to BinarySerializer
     */ writeFieldAndValue(field, value, isUnlModifyWorkaround = false) {
        const associatedValue = field.associatedType.from(value);
        if (associatedValue.toBytesSink === undefined || field.name === undefined) {
            throw new Error();
        }
        this.sink.put(field.header);
        if (field.isVariableLengthEncoded) {
            this.writeLengthEncoded(associatedValue, isUnlModifyWorkaround);
        } else {
            associatedValue.toBytesSink(this.sink);
        }
    }
    /**
     * Write a variable length encoded value to the BinarySerializer
     *
     * @param value length encoded value to write to BytesList
     */ writeLengthEncoded(value, isUnlModifyWorkaround = false) {
        const bytes = new BytesList();
        if (!isUnlModifyWorkaround) {
            // this part doesn't happen for the Account field in a UNLModify transaction
            value.toBytesSink(bytes);
        }
        this.put(this.encodeVariableLength(bytes.getLength()));
        this.writeBytesList(bytes);
    }
}
exports.BinarySerializer = BinarySerializer; //# sourceMappingURL=binary-serializer.js.map
}),
"[project]/node_modules/ripple-binary-codec/dist/types/serialized-type.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Comparable = exports.SerializedType = void 0;
const binary_serializer_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/serdes/binary-serializer.js [app-ssr] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@xrplf/isomorphic/dist/utils/index.js [app-ssr] (ecmascript)");
/**
 * The base class for all binary-codec types
 */ class SerializedType {
    constructor(bytes){
        this.bytes = new Uint8Array(0);
        this.bytes = bytes !== null && bytes !== void 0 ? bytes : new Uint8Array(0);
    }
    static fromParser(parser, hint) {
        throw new Error('fromParser not implemented');
        return this.fromParser(parser, hint);
    }
    static from(value) {
        throw new Error('from not implemented');
        return this.from(value);
    }
    /**
     * Write the bytes representation of a SerializedType to a BytesList
     *
     * @param list The BytesList to write SerializedType bytes to
     */ toBytesSink(list) {
        list.put(this.bytes);
    }
    /**
     * Get the hex representation of a SerializedType's bytes
     *
     * @returns hex String of this.bytes
     */ toHex() {
        return (0, utils_1.bytesToHex)(this.toBytes());
    }
    /**
     * Get the bytes representation of a SerializedType
     *
     * @returns A Uint8Array of the bytes
     */ toBytes() {
        if (this.bytes) {
            return this.bytes;
        }
        const bytes = new binary_serializer_1.BytesList();
        this.toBytesSink(bytes);
        return bytes.toBytes();
    }
    /**
     * Return the JSON representation of a SerializedType
     *
     * @param _definitions rippled definitions used to parse the values of transaction types and such.
     *                          Unused in default, but used in STObject, STArray
     *                          Can be customized for sidechains and amendments.
     * @returns any type, if not overloaded returns hexString representation of bytes
     */ toJSON(_definitions, _fieldName) {
        return this.toHex();
    }
    /**
     * @returns hexString representation of this.bytes
     */ toString() {
        return this.toHex();
    }
}
exports.SerializedType = SerializedType;
/**
 * Base class for SerializedTypes that are comparable.
 *
 * @template T - What types you want to allow comparisons between. You must specify all types. Primarily used to allow
 * comparisons between built-in types (like `string`) and SerializedType subclasses (like `Hash`).
 *
 * Ex. `class Hash extends Comparable<Hash | string>`
 */ class Comparable extends SerializedType {
    lt(other) {
        return this.compareTo(other) < 0;
    }
    eq(other) {
        return this.compareTo(other) === 0;
    }
    gt(other) {
        return this.compareTo(other) > 0;
    }
    gte(other) {
        return this.compareTo(other) > -1;
    }
    lte(other) {
        return this.compareTo(other) < 1;
    }
    /**
     * Overload this method to define how two Comparable SerializedTypes are compared
     *
     * @param other The comparable object to compare this to
     * @returns A number denoting the relationship of this and other
     */ compareTo(other) {
        throw new Error(`cannot compare ${this.toString()} and ${other.toString()}`);
    }
}
exports.Comparable = Comparable; //# sourceMappingURL=serialized-type.js.map
}),
"[project]/node_modules/ripple-binary-codec/dist/enums/constants.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DELEGATABLE_PERMISSIONS_WIDTH = exports.TRANSACTION_RESULT_WIDTH = exports.TRANSACTION_TYPE_WIDTH = exports.LEDGER_ENTRY_WIDTH = exports.TYPE_WIDTH = void 0;
exports.TYPE_WIDTH = 2; // UInt16
exports.LEDGER_ENTRY_WIDTH = 2; // UInt16
exports.TRANSACTION_TYPE_WIDTH = 2; // UInt16
exports.TRANSACTION_RESULT_WIDTH = 1; // UInt8
exports.DELEGATABLE_PERMISSIONS_WIDTH = 4; // UInt32
 //# sourceMappingURL=constants.js.map
}),
"[project]/node_modules/ripple-binary-codec/dist/enums/field.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FieldLookup = void 0;
const bytes_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/enums/bytes.js [app-ssr] (ecmascript)");
const serialized_type_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/types/serialized-type.js [app-ssr] (ecmascript)");
const constants_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/enums/constants.js [app-ssr] (ecmascript)");
/*
 * @brief: Serialize a field based on type_code and Field.nth
 */ function fieldHeader(type, nth) {
    const header = [];
    if (type < 16) {
        if (nth < 16) {
            header.push(type << 4 | nth);
        } else {
            header.push(type << 4, nth);
        }
    } else if (nth < 16) {
        header.push(nth, type);
    } else {
        header.push(0, type, nth);
    }
    return Uint8Array.from(header);
}
function buildField([name, info], typeOrdinal) {
    const field = fieldHeader(typeOrdinal, info.nth);
    return {
        name: name,
        nth: info.nth,
        isVariableLengthEncoded: info.isVLEncoded,
        isSerialized: info.isSerialized,
        isSigningField: info.isSigningField,
        ordinal: typeOrdinal << 16 | info.nth,
        type: new bytes_1.Bytes(info.type, typeOrdinal, constants_1.TYPE_WIDTH),
        header: field,
        associatedType: serialized_type_1.SerializedType
    };
}
/*
 * @brief: The collection of all fields as defined in definitions.json
 */ class FieldLookup {
    constructor(fields, types){
        fields.forEach(([name, field_info])=>{
            const typeOrdinal = types[field_info.type];
            this[name] = buildField([
                name,
                field_info
            ], typeOrdinal);
            this[this[name].ordinal.toString()] = this[name];
        });
    }
    fromString(value) {
        return this[value];
    }
}
exports.FieldLookup = FieldLookup; //# sourceMappingURL=field.js.map
}),
"[project]/node_modules/ripple-binary-codec/dist/enums/xrpl-definitions-base.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BytesLookup = exports.Bytes = exports.FieldLookup = exports.XrplDefinitionsBase = void 0;
const bytes_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/enums/bytes.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "Bytes", {
    enumerable: true,
    get: function() {
        return bytes_1.Bytes;
    }
});
Object.defineProperty(exports, "BytesLookup", {
    enumerable: true,
    get: function() {
        return bytes_1.BytesLookup;
    }
});
const field_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/enums/field.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "FieldLookup", {
    enumerable: true,
    get: function() {
        return field_1.FieldLookup;
    }
});
const constants_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/enums/constants.js [app-ssr] (ecmascript)");
/**
 * Stores the various types and fields for rippled to be used to encode/decode information later on.
 * XrplDefinitions should be instantiated instead of this class.
 */ class XrplDefinitionsBase {
    /**
     * Present rippled types in a typed and updatable format.
     * For an example of the input format see `definitions.json`.
     * To generate a new definitions file from rippled source code, use the tool at
     * `packages/ripple-binary-codec/tools/generateDefinitions.js`.
     *
     * See the definitions.test.js file for examples of how to create your own updated definitions.json.
     *
     * @param enums - A json encoding of the core types, transaction types, transaction results, transaction names, and fields.
     * @param types - A list of type objects with the same name as the fields defined.
     *              You can use the coreTypes object if you are not adding new types.
     */ constructor(enums, types){
        this.type = new bytes_1.BytesLookup(enums.TYPES, constants_1.TYPE_WIDTH);
        this.ledgerEntryType = new bytes_1.BytesLookup(enums.LEDGER_ENTRY_TYPES, constants_1.LEDGER_ENTRY_WIDTH);
        this.transactionType = new bytes_1.BytesLookup(enums.TRANSACTION_TYPES, constants_1.TRANSACTION_TYPE_WIDTH);
        this.transactionResult = new bytes_1.BytesLookup(enums.TRANSACTION_RESULTS, constants_1.TRANSACTION_RESULT_WIDTH);
        this.field = new field_1.FieldLookup(enums.FIELDS, enums.TYPES);
        this.transactionNames = Object.entries(enums.TRANSACTION_TYPES).filter(([_key, value])=>value >= 0).map(([key, _value])=>key);
        this.dataTypes = {}; // Filled in via associateTypes
        this.associateTypes(types);
        this.granularPermissions = {
            TrustlineAuthorize: 65537,
            TrustlineFreeze: 65538,
            TrustlineUnfreeze: 65539,
            AccountDomainSet: 65540,
            AccountEmailHashSet: 65541,
            AccountMessageKeySet: 65542,
            AccountTransferRateSet: 65543,
            AccountTickSizeSet: 65544,
            PaymentMint: 65545,
            PaymentBurn: 65546,
            MPTokenIssuanceLock: 65547,
            MPTokenIssuanceUnlock: 65548
        };
        const incrementedTransactionTypes = Object.fromEntries(Object.entries(enums.TRANSACTION_TYPES).map(([key, value])=>[
                key,
                value + 1
            ]));
        const combinedPermissions = Object.assign(Object.assign({}, this.granularPermissions), incrementedTransactionTypes);
        this.delegatablePermissions = new bytes_1.BytesLookup(combinedPermissions, constants_1.DELEGATABLE_PERMISSIONS_WIDTH);
    }
    /**
     * Associates each Field to a corresponding class that TypeScript can recognize.
     *
     * @param types a list of type objects with the same name as the fields defined.
     *              Defaults to xrpl.js's core type definitions.
     */ associateTypes(types) {
        // Overwrite any existing type definitions with the given types
        this.dataTypes = Object.assign({}, this.dataTypes, types);
        Object.values(this.field).forEach((field)=>{
            field.associatedType = this.dataTypes[field.type.name];
        });
        this.field['TransactionType'].associatedType = this.transactionType;
        this.field['TransactionResult'].associatedType = this.transactionResult;
        this.field['LedgerEntryType'].associatedType = this.ledgerEntryType;
        if (this.field['PermissionValue']) {
            this.field['PermissionValue'].associatedType = this.delegatablePermissions;
        }
    }
    getAssociatedTypes() {
        return this.dataTypes;
    }
}
exports.XrplDefinitionsBase = XrplDefinitionsBase; //# sourceMappingURL=xrpl-definitions-base.js.map
}),
"[project]/node_modules/ripple-binary-codec/dist/enums/index.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TRANSACTION_TYPES = exports.TransactionType = exports.TransactionResult = exports.LedgerEntryType = exports.Type = exports.Field = exports.DEFAULT_DEFINITIONS = exports.XrplDefinitionsBase = exports.Bytes = void 0;
const definitions_json_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/enums/definitions.json (json)"));
const xrpl_definitions_base_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/enums/xrpl-definitions-base.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "XrplDefinitionsBase", {
    enumerable: true,
    get: function() {
        return xrpl_definitions_base_1.XrplDefinitionsBase;
    }
});
Object.defineProperty(exports, "Bytes", {
    enumerable: true,
    get: function() {
        return xrpl_definitions_base_1.Bytes;
    }
});
/**
 * By default, coreTypes from the `types` folder is where known type definitions are initialized to avoid import cycles.
 */ const DEFAULT_DEFINITIONS = new xrpl_definitions_base_1.XrplDefinitionsBase(definitions_json_1.default, {});
exports.DEFAULT_DEFINITIONS = DEFAULT_DEFINITIONS;
const Type = DEFAULT_DEFINITIONS.type;
exports.Type = Type;
const LedgerEntryType = DEFAULT_DEFINITIONS.ledgerEntryType;
exports.LedgerEntryType = LedgerEntryType;
const TransactionType = DEFAULT_DEFINITIONS.transactionType;
exports.TransactionType = TransactionType;
const TransactionResult = DEFAULT_DEFINITIONS.transactionResult;
exports.TransactionResult = TransactionResult;
const Field = DEFAULT_DEFINITIONS.field;
exports.Field = Field;
/*
 * @brief: All valid transaction types
 */ const TRANSACTION_TYPES = DEFAULT_DEFINITIONS.transactionNames;
exports.TRANSACTION_TYPES = TRANSACTION_TYPES; //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/ripple-binary-codec/dist/utils.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.compare = exports.equal = exports.readInt64BE = exports.readInt32BE = exports.readUInt32BE = exports.readUInt16BE = exports.writeInt64BE = exports.writeInt32BE = exports.writeUInt32BE = exports.writeUInt16BE = exports.writeUInt8 = void 0;
/**
 * Writes value to array at the specified offset. The value must be a valid unsigned 8-bit integer.
 * @param array Uint8Array to be written to
 * @param value Number to be written to array.
 * @param offset plus the number of bytes written.
 */ function writeUInt8(array, value, offset) {
    value = Number(value);
    array[offset] = value;
}
exports.writeUInt8 = writeUInt8;
/**
 * Writes value to array at the specified offset as big-endian. The value must be a valid unsigned 16-bit integer.
 * @param array Uint8Array to be written to
 * @param value Number to be written to array.
 * @param offset plus the number of bytes written.
 */ function writeUInt16BE(array, value, offset) {
    value = Number(value);
    array[offset] = value >>> 8;
    array[offset + 1] = value;
}
exports.writeUInt16BE = writeUInt16BE;
/**
 * Writes value to array at the specified offset as big-endian. The value must be a valid unsigned 32-bit integer.
 * @param array Uint8Array to be written to
 * @param value Number to be written to array.
 * @param offset plus the number of bytes written.
 */ function writeUInt32BE(array, value, offset) {
    array[offset] = value >>> 24 & 0xff;
    array[offset + 1] = value >>> 16 & 0xff;
    array[offset + 2] = value >>> 8 & 0xff;
    array[offset + 3] = value & 0xff;
}
exports.writeUInt32BE = writeUInt32BE;
/**
 * Writes a signed 32-bit integer to a Uint8Array at the specified offset (big-endian).
 *
 * @param array - The Uint8Array to write to.
 * @param value - The signed 32-bit integer to write.
 * @param offset - The offset at which to write.
 */ function writeInt32BE(array, value, offset) {
    new DataView(array.buffer, array.byteOffset, array.byteLength).setInt32(offset, value, false);
}
exports.writeInt32BE = writeInt32BE;
/**
 * Writes a signed 64-bit integer (BigInt) to a Uint8Array at the specified offset (big-endian).
 *
 * @param array - The Uint8Array to write to.
 * @param value - The signed 64-bit integer (BigInt) to write.
 * @param offset - The offset at which to write.
 */ function writeInt64BE(array, value, offset) {
    new DataView(array.buffer, array.byteOffset, array.byteLength).setBigInt64(offset, value, false);
}
exports.writeInt64BE = writeInt64BE;
/**
 * Reads an unsigned, big-endian 16-bit integer from the array at the specified offset.
 * @param array Uint8Array to read
 * @param offset Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 2
 */ function readUInt16BE(array, offset) {
    return new DataView(array.buffer).getUint16(offset, false).toString(10);
}
exports.readUInt16BE = readUInt16BE;
/**
 * Reads an unsigned, big-endian 16-bit integer from the array at the specified offset.
 * @param array Uint8Array to read
 * @param offset Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 4
 */ function readUInt32BE(array, offset) {
    return new DataView(array.buffer).getUint32(offset, false).toString(10);
}
exports.readUInt32BE = readUInt32BE;
/**
 * Reads a signed 32-bit integer from a Uint8Array at the specified offset (big-endian).
 *
 * @param array - The Uint8Array to read from.
 * @param offset - The offset at which to start reading.
 * @returns The signed 32-bit integer.
 */ function readInt32BE(array, offset) {
    return new DataView(array.buffer, array.byteOffset, array.byteLength).getInt32(offset, false);
}
exports.readInt32BE = readInt32BE;
/**
 * Reads a signed 64-bit integer (BigInt) from a Uint8Array at the specified offset (big-endian).
 *
 * @param array - The Uint8Array to read from.
 * @param offset - The offset at which to start reading.
 * @returns The signed 64-bit integer (BigInt).
 */ function readInt64BE(array, offset) {
    return new DataView(array.buffer, array.byteOffset, array.byteLength).getBigInt64(offset, false);
}
exports.readInt64BE = readInt64BE;
/**
 * Compares two Uint8Array or ArrayBuffers
 * @param a first array to compare
 * @param b second array to compare
 */ function equal(a, b) {
    const aUInt = a instanceof ArrayBuffer ? new Uint8Array(a, 0) : a;
    const bUInt = b instanceof ArrayBuffer ? new Uint8Array(b, 0) : b;
    if (aUInt.byteLength != bUInt.byteLength) return false;
    if (aligned32(aUInt) && aligned32(bUInt)) return compare32(aUInt, bUInt) === 0;
    if (aligned16(aUInt) && aligned16(bUInt)) return compare16(aUInt, bUInt) === 0;
    return compare8(aUInt, bUInt) === 0;
}
exports.equal = equal;
/**
 * Compares two 8 bit aligned arrays
 * @param a first array to compare
 * @param b second array to compare
 */ function compare8(a, b) {
    const ua = new Uint8Array(a.buffer, a.byteOffset, a.byteLength);
    const ub = new Uint8Array(b.buffer, b.byteOffset, b.byteLength);
    return compare(ua, ub);
}
/**
 * Compares two 16 bit aligned arrays
 * @param a first array to compare
 * @param b second array to compare
 */ function compare16(a, b) {
    const ua = new Uint16Array(a.buffer, a.byteOffset, a.byteLength / 2);
    const ub = new Uint16Array(b.buffer, b.byteOffset, b.byteLength / 2);
    return compare(ua, ub);
}
/**
 * Compares two 32 bit aligned arrays
 * @param a first array to compare
 * @param b second array to compare
 */ function compare32(a, b) {
    const ua = new Uint32Array(a.buffer, a.byteOffset, a.byteLength / 4);
    const ub = new Uint32Array(b.buffer, b.byteOffset, b.byteLength / 4);
    return compare(ua, ub);
}
/**
 * Compare two TypedArrays
 * @param a first array to compare
 * @param b second array to compare
 */ function compare(a, b) {
    if (a.byteLength !== b.byteLength) {
        throw new Error('Cannot compare arrays of different length');
    }
    for(let i = 0; i < a.length - 1; i += 1){
        if (a[i] > b[i]) return 1;
        if (a[i] < b[i]) return -1;
    }
    return 0;
}
exports.compare = compare;
/**
 * Determine if TypedArray is 16 bit aligned
 * @param array The array to check
 */ function aligned16(array) {
    return array.byteOffset % 2 === 0 && array.byteLength % 2 === 0;
}
/**
 * Determine if TypedArray is 32 bit aligned
 * @param array The array to check
 */ function aligned32(array) {
    return array.byteOffset % 4 === 0 && array.byteLength % 4 === 0;
} //# sourceMappingURL=utils.js.map
}),
"[project]/node_modules/ripple-binary-codec/dist/types/hash.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Hash = void 0;
const serialized_type_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/types/serialized-type.js [app-ssr] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@xrplf/isomorphic/dist/utils/index.js [app-ssr] (ecmascript)");
const utils_2 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/utils.js [app-ssr] (ecmascript)");
/**
 * Base class defining how to encode and decode hashes
 */ class Hash extends serialized_type_1.Comparable {
    constructor(bytes){
        super(bytes);
        if (this.bytes.length !== this.constructor.width) {
            throw new Error(`Invalid Hash length ${this.bytes.byteLength}`);
        }
    }
    /**
     * Construct a Hash object from an existing Hash object or a hex-string
     *
     * @param value A hash object or hex-string of a hash
     */ static from(value) {
        if (value instanceof this) {
            return value;
        }
        if (typeof value === 'string') {
            if (!utils_1.HEX_REGEX.test(value)) {
                throw new Error(`Invalid hash string ${value}`);
            }
            return new this((0, utils_1.hexToBytes)(value));
        }
        throw new Error('Cannot construct Hash from given value');
    }
    /**
     * Read a Hash object from a BinaryParser
     *
     * @param parser BinaryParser to read the hash from
     * @param hint length of the bytes to read, optional
     */ static fromParser(parser, hint) {
        return new this(parser.read(hint !== null && hint !== void 0 ? hint : this.width));
    }
    /**
     * Overloaded operator for comparing two hash objects
     *
     * @param other The Hash to compare this to
     */ compareTo(other) {
        return (0, utils_2.compare)(this.bytes, this.constructor.from(other).bytes);
    }
    /**
     * @returns the hex-string representation of this Hash
     */ toString() {
        return this.toHex();
    }
    /**
     * Returns four bits at the specified depth within a hash
     *
     * @param depth The depth of the four bits
     * @returns The number represented by the four bits
     */ nibblet(depth) {
        const byteIx = depth > 0 ? depth / 2 | 0 : 0;
        let b = this.bytes[byteIx];
        if (depth % 2 === 0) {
            b = (b & 0xf0) >>> 4;
        } else {
            b = b & 0x0f;
        }
        return b;
    }
}
exports.Hash = Hash; //# sourceMappingURL=hash.js.map
}),
"[project]/node_modules/ripple-binary-codec/dist/types/hash-160.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Hash160 = void 0;
const hash_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/types/hash.js [app-ssr] (ecmascript)");
/**
 * Hash with a width of 160 bits
 */ class Hash160 extends hash_1.Hash {
    constructor(bytes){
        if (bytes && bytes.byteLength === 0) {
            bytes = Hash160.ZERO_160.bytes;
        }
        super(bytes !== null && bytes !== void 0 ? bytes : Hash160.ZERO_160.bytes);
    }
}
exports.Hash160 = Hash160;
Hash160.width = 20;
Hash160.ZERO_160 = new Hash160(new Uint8Array(Hash160.width)); //# sourceMappingURL=hash-160.js.map
}),
"[project]/node_modules/ripple-binary-codec/dist/types/account-id.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AccountID = void 0;
const ripple_address_codec_1 = __turbopack_context__.r("[project]/node_modules/ripple-address-codec/dist/index.js [app-ssr] (ecmascript)");
const hash_160_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/types/hash-160.js [app-ssr] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@xrplf/isomorphic/dist/utils/index.js [app-ssr] (ecmascript)");
const HEX_REGEX = /^[A-F0-9]{40}$/;
/**
 * Class defining how to encode and decode an AccountID
 */ class AccountID extends hash_160_1.Hash160 {
    constructor(bytes){
        super(bytes !== null && bytes !== void 0 ? bytes : AccountID.defaultAccountID.bytes);
    }
    /**
     * Defines how to construct an AccountID
     *
     * @param value either an existing AccountID, a hex-string, or a base58 r-Address
     * @returns an AccountID object
     */ static from(value) {
        if (value instanceof AccountID) {
            return value;
        }
        if (typeof value === 'string') {
            if (value === '') {
                return new AccountID();
            }
            return HEX_REGEX.test(value) ? new AccountID((0, utils_1.hexToBytes)(value)) : this.fromBase58(value);
        }
        throw new Error('Cannot construct AccountID from value given');
    }
    /**
     * Defines how to build an AccountID from a base58 r-Address
     *
     * @param value a base58 r-Address
     * @returns an AccountID object
     */ static fromBase58(value) {
        if ((0, ripple_address_codec_1.isValidXAddress)(value)) {
            const classic = (0, ripple_address_codec_1.xAddressToClassicAddress)(value);
            if (classic.tag !== false) throw new Error('Only allowed to have tag on Account or Destination');
            value = classic.classicAddress;
        }
        return new AccountID(Uint8Array.from((0, ripple_address_codec_1.decodeAccountID)(value)));
    }
    /**
     * Overload of toJSON
     *
     * @returns the base58 string for this AccountID
     */ toJSON() {
        return this.toBase58();
    }
    /**
     * Defines how to encode AccountID into a base58 address
     *
     * @returns the base58 string defined by this.bytes
     */ toBase58() {
        return (0, ripple_address_codec_1.encodeAccountID)(this.bytes);
    }
}
exports.AccountID = AccountID;
AccountID.defaultAccountID = new AccountID(new Uint8Array(20)); //# sourceMappingURL=account-id.js.map
}),
"[project]/node_modules/ripple-binary-codec/dist/serdes/binary-parser.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BinaryParser = void 0;
const enums_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/enums/index.js [app-ssr] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@xrplf/isomorphic/dist/utils/index.js [app-ssr] (ecmascript)");
/**
 * BinaryParser is used to compute fields and values from a HexString
 */ class BinaryParser {
    /**
     * Initialize bytes to a hex string
     *
     * @param hexBytes a hex string
     * @param definitions Rippled definitions used to parse the values of transaction types and such.
     *                          Can be customized for sidechains and amendments.
     */ constructor(hexBytes, definitions = enums_1.DEFAULT_DEFINITIONS){
        this.bytes = (0, utils_1.hexToBytes)(hexBytes);
        this.definitions = definitions;
    }
    /**
     * Peek the first byte of the BinaryParser
     *
     * @returns The first byte of the BinaryParser
     */ peek() {
        if (this.bytes.byteLength === 0) {
            throw new Error();
        }
        return this.bytes[0];
    }
    /**
     * Consume the first n bytes of the BinaryParser
     *
     * @param n the number of bytes to skip
     */ skip(n) {
        if (n > this.bytes.byteLength) {
            throw new Error();
        }
        this.bytes = this.bytes.slice(n);
    }
    /**
     * read the first n bytes from the BinaryParser
     *
     * @param n The number of bytes to read
     * @return The bytes
     */ read(n) {
        if (n > this.bytes.byteLength) {
            throw new Error();
        }
        const slice = this.bytes.slice(0, n);
        this.skip(n);
        return slice;
    }
    /**
     * Read an integer of given size
     *
     * @param n The number of bytes to read
     * @return The number represented by those bytes
     */ readUIntN(n) {
        if (0 >= n || n > 4) {
            throw new Error('invalid n');
        }
        return this.read(n).reduce((a, b)=>a << 8 | b) >>> 0;
    }
    readUInt8() {
        return this.readUIntN(1);
    }
    readUInt16() {
        return this.readUIntN(2);
    }
    readUInt32() {
        return this.readUIntN(4);
    }
    size() {
        return this.bytes.byteLength;
    }
    end(customEnd) {
        const length = this.bytes.byteLength;
        return length === 0 || customEnd !== undefined && length <= customEnd;
    }
    /**
     * Reads variable length encoded bytes
     *
     * @return The variable length bytes
     */ readVariableLength() {
        return this.read(this.readVariableLengthLength());
    }
    /**
     * Reads the length of the variable length encoded bytes
     *
     * @return The length of the variable length encoded bytes
     */ readVariableLengthLength() {
        const b1 = this.readUInt8();
        if (b1 <= 192) {
            return b1;
        } else if (b1 <= 240) {
            const b2 = this.readUInt8();
            return 193 + (b1 - 193) * 256 + b2;
        } else if (b1 <= 254) {
            const b2 = this.readUInt8();
            const b3 = this.readUInt8();
            return 12481 + (b1 - 241) * 65536 + b2 * 256 + b3;
        }
        throw new Error('Invalid variable length indicator');
    }
    /**
     * Reads the field ordinal from the BinaryParser
     *
     * @return Field ordinal
     */ readFieldOrdinal() {
        let type = this.readUInt8();
        let nth = type & 15;
        type >>= 4;
        if (type === 0) {
            type = this.readUInt8();
            if (type === 0 || type < 16) {
                throw new Error(`Cannot read FieldOrdinal, type_code ${type} out of range`);
            }
        }
        if (nth === 0) {
            nth = this.readUInt8();
            if (nth === 0 || nth < 16) {
                throw new Error(`Cannot read FieldOrdinal, field_code ${nth} out of range`);
            }
        }
        return type << 16 | nth;
    }
    /**
     * Read the field from the BinaryParser
     *
     * @return The field represented by the bytes at the head of the BinaryParser
     */ readField() {
        return this.definitions.field.fromString(this.readFieldOrdinal().toString());
    }
    /**
     * Read a given type from the BinaryParser
     *
     * @param type The type that you want to read from the BinaryParser
     * @return The instance of that type read from the BinaryParser
     */ readType(type) {
        return type.fromParser(this);
    }
    /**
     * Get the type associated with a given field
     *
     * @param field The field that you wan to get the type of
     * @return The type associated with the given field
     */ typeForField(field) {
        return field.associatedType;
    }
    /**
     * Read value of the type specified by field from the BinaryParser
     *
     * @param field The field that you want to get the associated value for
     * @return The value associated with the given field
     */ readFieldValue(field) {
        const type = this.typeForField(field);
        if (!type) {
            throw new Error(`unsupported: (${field.name}, ${field.type.name})`);
        }
        const sizeHint = field.isVariableLengthEncoded ? this.readVariableLengthLength() : undefined;
        const value = type.fromParser(this, sizeHint);
        if (value === undefined) {
            throw new Error(`fromParser for (${field.name}, ${field.type.name}) -> undefined `);
        }
        return value;
    }
    /**
     * Get the next field and value from the BinaryParser
     *
     * @return The field and value
     */ readFieldAndValue() {
        const field = this.readField();
        return [
            field,
            this.readFieldValue(field)
        ];
    }
}
exports.BinaryParser = BinaryParser; //# sourceMappingURL=binary-parser.js.map
}),
"[project]/node_modules/ripple-binary-codec/dist/types/currency.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Currency = void 0;
const hash_160_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/types/hash-160.js [app-ssr] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@xrplf/isomorphic/dist/utils/index.js [app-ssr] (ecmascript)");
const XRP_HEX_REGEX = /^0{40}$/;
const ISO_REGEX = /^[A-Z0-9a-z?!@#$%^&*(){}[\]|]{3}$/;
const HEX_REGEX = /^[A-F0-9]{40}$/;
// eslint-disable-next-line no-control-regex
const STANDARD_FORMAT_HEX_REGEX = /^0{24}[\x00-\x7F]{6}0{10}$/;
/**
 * Convert an ISO code to a currency bytes representation
 */ function isoToBytes(iso) {
    const bytes = new Uint8Array(20);
    if (iso !== 'XRP') {
        const isoBytes = iso.split('').map((c)=>c.charCodeAt(0));
        bytes.set(isoBytes, 12);
    }
    return bytes;
}
/**
 * Tests if ISO is a valid iso code
 */ function isIsoCode(iso) {
    return ISO_REGEX.test(iso);
}
function isoCodeFromHex(code) {
    const iso = (0, utils_1.hexToString)((0, utils_1.bytesToHex)(code));
    if (iso === 'XRP') {
        return null;
    }
    if (isIsoCode(iso)) {
        return iso;
    }
    return null;
}
/**
 * Tests if hex is a valid hex-string
 */ function isHex(hex) {
    return HEX_REGEX.test(hex);
}
/**
 * Tests if a string is a valid representation of a currency
 */ function isStringRepresentation(input) {
    return input.length === 3 || isHex(input);
}
/**
 * Tests if a Uint8Array is a valid representation of a currency
 */ function isBytesArray(bytes) {
    return bytes.byteLength === 20;
}
/**
 * Ensures that a value is a valid representation of a currency
 */ function isValidRepresentation(input) {
    return input instanceof Uint8Array ? isBytesArray(input) : isStringRepresentation(input);
}
/**
 * Generate bytes from a string or UInt8Array representation of a currency
 */ function bytesFromRepresentation(input) {
    if (!isValidRepresentation(input)) {
        throw new Error(`Unsupported Currency representation: ${input}`);
    }
    return input.length === 3 ? isoToBytes(input) : (0, utils_1.hexToBytes)(input);
}
/**
 * Class defining how to encode and decode Currencies
 */ class Currency extends hash_160_1.Hash160 {
    constructor(byteBuf){
        super(byteBuf !== null && byteBuf !== void 0 ? byteBuf : Currency.XRP.bytes);
        const hex = (0, utils_1.bytesToHex)(this.bytes);
        if (XRP_HEX_REGEX.test(hex)) {
            this._iso = 'XRP';
        } else if (STANDARD_FORMAT_HEX_REGEX.test(hex)) {
            this._iso = isoCodeFromHex(this.bytes.slice(12, 15));
        } else {
            this._iso = null;
        }
    }
    /**
     * Return the ISO code of this currency
     *
     * @returns ISO code if it exists, else null
     */ iso() {
        return this._iso;
    }
    /**
     * Constructs a Currency object
     *
     * @param val Currency object or a string representation of a currency
     */ static from(value) {
        if (value instanceof Currency) {
            return value;
        }
        if (typeof value === 'string') {
            return new Currency(bytesFromRepresentation(value));
        }
        throw new Error('Cannot construct Currency from value given');
    }
    /**
     * Gets the JSON representation of a currency
     *
     * @returns JSON representation
     */ toJSON() {
        const iso = this.iso();
        if (iso !== null) {
            return iso;
        }
        return (0, utils_1.bytesToHex)(this.bytes);
    }
}
exports.Currency = Currency;
Currency.XRP = new Currency(new Uint8Array(20)); //# sourceMappingURL=currency.js.map
}),
"[project]/node_modules/ripple-binary-codec/dist/types/hash-192.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Hash192 = void 0;
const hash_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/types/hash.js [app-ssr] (ecmascript)");
/**
 * Hash with a width of 192 bits
 */ class Hash192 extends hash_1.Hash {
    constructor(bytes){
        if (bytes && bytes.byteLength === 0) {
            bytes = Hash192.ZERO_192.bytes;
        }
        super(bytes !== null && bytes !== void 0 ? bytes : Hash192.ZERO_192.bytes);
    }
}
exports.Hash192 = Hash192;
Hash192.width = 24;
Hash192.ZERO_192 = new Hash192(new Uint8Array(Hash192.width)); //# sourceMappingURL=hash-192.js.map
}),
"[project]/node_modules/ripple-binary-codec/dist/types/amount.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Amount = void 0;
const binary_parser_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/serdes/binary-parser.js [app-ssr] (ecmascript)");
const account_id_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/types/account-id.js [app-ssr] (ecmascript)");
const currency_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/types/currency.js [app-ssr] (ecmascript)");
const serialized_type_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/types/serialized-type.js [app-ssr] (ecmascript)");
const bignumber_js_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/bignumber.js/bignumber.js [app-ssr] (ecmascript)"));
const utils_1 = __turbopack_context__.r("[project]/node_modules/@xrplf/isomorphic/dist/utils/index.js [app-ssr] (ecmascript)");
const utils_2 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/utils.js [app-ssr] (ecmascript)");
const hash_192_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/types/hash-192.js [app-ssr] (ecmascript)");
/**
 * Constants for validating amounts
 */ const MIN_IOU_EXPONENT = -96;
const MAX_IOU_EXPONENT = 80;
const MAX_IOU_PRECISION = 16;
const MAX_DROPS = new bignumber_js_1.default('1e17');
const MIN_XRP = new bignumber_js_1.default('1e-6');
const mask = BigInt(0x00000000ffffffff);
const mptMask = BigInt(0x8000000000000000);
/**
 * BigNumber configuration for Amount IOUs
 */ bignumber_js_1.default.config({
    EXPONENTIAL_AT: [
        MIN_IOU_EXPONENT - MAX_IOU_PRECISION,
        MAX_IOU_EXPONENT + MAX_IOU_PRECISION
    ]
});
/**
 * Type guard for AmountObjectIOU
 */ function isAmountObjectIOU(arg) {
    const keys = Object.keys(arg).sort();
    return keys.length === 3 && keys[0] === 'currency' && keys[1] === 'issuer' && keys[2] === 'value';
}
/**
 * Type guard for AmountObjectMPT
 */ function isAmountObjectMPT(arg) {
    const keys = Object.keys(arg).sort();
    return keys.length === 2 && keys[0] === 'mpt_issuance_id' && keys[1] === 'value';
}
/**
 * Class for serializing/Deserializing Amounts
 */ class Amount extends serialized_type_1.SerializedType {
    constructor(bytes){
        super(bytes !== null && bytes !== void 0 ? bytes : Amount.defaultAmount.bytes);
    }
    /**
     * Construct an amount from an IOU, MPT or string amount
     *
     * @param value An Amount, object representing an IOU, or a string
     *     representing an integer amount
     * @returns An Amount object
     */ static from(value) {
        if (value instanceof Amount) {
            return value;
        }
        let amount = new Uint8Array(8);
        if (typeof value === 'string') {
            Amount.assertXrpIsValid(value);
            const number = BigInt(value);
            const intBuf = [
                new Uint8Array(4),
                new Uint8Array(4)
            ];
            (0, utils_2.writeUInt32BE)(intBuf[0], Number(number >> BigInt(32)), 0);
            (0, utils_2.writeUInt32BE)(intBuf[1], Number(number & BigInt(mask)), 0);
            amount = (0, utils_1.concat)(intBuf);
            amount[0] |= 0x40;
            return new Amount(amount);
        }
        if (isAmountObjectIOU(value)) {
            const number = new bignumber_js_1.default(value.value);
            Amount.assertIouIsValid(number);
            if (number.isZero()) {
                amount[0] |= 0x80;
            } else {
                const integerNumberString = number.times(`1e${-((number.e || 0) - 15)}`).abs().toString();
                const num = BigInt(integerNumberString);
                const intBuf = [
                    new Uint8Array(4),
                    new Uint8Array(4)
                ];
                (0, utils_2.writeUInt32BE)(intBuf[0], Number(num >> BigInt(32)), 0);
                (0, utils_2.writeUInt32BE)(intBuf[1], Number(num & BigInt(mask)), 0);
                amount = (0, utils_1.concat)(intBuf);
                amount[0] |= 0x80;
                if (number.gt(new bignumber_js_1.default(0))) {
                    amount[0] |= 0x40;
                }
                const exponent = (number.e || 0) - 15;
                const exponentByte = 97 + exponent;
                amount[0] |= exponentByte >>> 2;
                amount[1] |= (exponentByte & 0x03) << 6;
            }
            const currency = currency_1.Currency.from(value.currency).toBytes();
            const issuer = account_id_1.AccountID.from(value.issuer).toBytes();
            return new Amount((0, utils_1.concat)([
                amount,
                currency,
                issuer
            ]));
        }
        if (isAmountObjectMPT(value)) {
            Amount.assertMptIsValid(value.value);
            let leadingByte = new Uint8Array(1);
            leadingByte[0] |= 0x60;
            const num = BigInt(value.value);
            const intBuf = [
                new Uint8Array(4),
                new Uint8Array(4)
            ];
            (0, utils_2.writeUInt32BE)(intBuf[0], Number(num >> BigInt(32)), 0);
            (0, utils_2.writeUInt32BE)(intBuf[1], Number(num & BigInt(mask)), 0);
            amount = (0, utils_1.concat)(intBuf);
            const mptIssuanceID = hash_192_1.Hash192.from(value.mpt_issuance_id).toBytes();
            return new Amount((0, utils_1.concat)([
                leadingByte,
                amount,
                mptIssuanceID
            ]));
        }
        throw new Error('Invalid type to construct an Amount');
    }
    /**
     * Read an amount from a BinaryParser
     *
     * @param parser BinaryParser to read the Amount from
     * @returns An Amount object
     */ static fromParser(parser) {
        const isIOU = parser.peek() & 0x80;
        if (isIOU) return new Amount(parser.read(48));
        // the amount can be either MPT or XRP at this point
        const isMPT = parser.peek() & 0x20;
        const numBytes = isMPT ? 33 : 8;
        return new Amount(parser.read(numBytes));
    }
    /**
     * Get the JSON representation of this Amount
     *
     * @returns the JSON interpretation of this.bytes
     */ toJSON() {
        if (this.isNative()) {
            const bytes = this.bytes;
            const isPositive = bytes[0] & 0x40;
            const sign = isPositive ? '' : '-';
            bytes[0] &= 0x3f;
            const msb = BigInt((0, utils_2.readUInt32BE)(bytes.slice(0, 4), 0));
            const lsb = BigInt((0, utils_2.readUInt32BE)(bytes.slice(4), 0));
            const num = msb << BigInt(32) | lsb;
            return `${sign}${num.toString()}`;
        }
        if (this.isIOU()) {
            const parser = new binary_parser_1.BinaryParser(this.toString());
            const mantissa = parser.read(8);
            const currency = currency_1.Currency.fromParser(parser);
            const issuer = account_id_1.AccountID.fromParser(parser);
            const b1 = mantissa[0];
            const b2 = mantissa[1];
            const isPositive = b1 & 0x40;
            const sign = isPositive ? '' : '-';
            const exponent = ((b1 & 0x3f) << 2) + ((b2 & 0xff) >> 6) - 97;
            mantissa[0] = 0;
            mantissa[1] &= 0x3f;
            const value = new bignumber_js_1.default(`${sign}0x${(0, utils_1.bytesToHex)(mantissa)}`).times(`1e${exponent}`);
            Amount.assertIouIsValid(value);
            return {
                value: value.toString(),
                currency: currency.toJSON(),
                issuer: issuer.toJSON()
            };
        }
        if (this.isMPT()) {
            const parser = new binary_parser_1.BinaryParser(this.toString());
            const leadingByte = parser.read(1);
            const amount = parser.read(8);
            const mptID = hash_192_1.Hash192.fromParser(parser);
            const isPositive = leadingByte[0] & 0x40;
            const sign = isPositive ? '' : '-';
            const msb = BigInt((0, utils_2.readUInt32BE)(amount.slice(0, 4), 0));
            const lsb = BigInt((0, utils_2.readUInt32BE)(amount.slice(4), 0));
            const num = msb << BigInt(32) | lsb;
            return {
                value: `${sign}${num.toString()}`,
                mpt_issuance_id: mptID.toString()
            };
        }
        throw new Error('Invalid amount to construct JSON');
    }
    /**
     * Validate XRP amount
     *
     * @param amount String representing XRP amount
     * @returns void, but will throw if invalid amount
     */ static assertXrpIsValid(amount) {
        if (amount.indexOf('.') !== -1) {
            throw new Error(`${amount.toString()} is an illegal amount`);
        }
        const decimal = new bignumber_js_1.default(amount);
        if (!decimal.isZero()) {
            if (decimal.lt(MIN_XRP) || decimal.gt(MAX_DROPS)) {
                throw new Error(`${amount.toString()} is an illegal amount`);
            }
        }
    }
    /**
     * Validate IOU.value amount
     *
     * @param decimal BigNumber object representing IOU.value
     * @returns void, but will throw if invalid amount
     */ static assertIouIsValid(decimal) {
        if (!decimal.isZero()) {
            const p = decimal.precision();
            const e = (decimal.e || 0) - 15;
            if (p > MAX_IOU_PRECISION || e > MAX_IOU_EXPONENT || e < MIN_IOU_EXPONENT) {
                throw new Error('Decimal precision out of range');
            }
            this.verifyNoDecimal(decimal);
        }
    }
    /**
     * Validate MPT.value amount
     *
     * @param decimal BigNumber object representing MPT.value
     * @returns void, but will throw if invalid amount
     */ static assertMptIsValid(amount) {
        if (amount.indexOf('.') !== -1) {
            throw new Error(`${amount.toString()} is an illegal amount`);
        }
        const decimal = new bignumber_js_1.default(amount);
        if (!decimal.isZero()) {
            if (decimal < (0, bignumber_js_1.default)(0)) {
                throw new Error(`${amount.toString()} is an illegal amount`);
            }
            if (Number(BigInt(amount) & BigInt(mptMask)) != 0) {
                throw new Error(`${amount.toString()} is an illegal amount`);
            }
        }
    }
    /**
     * Ensure that the value after being multiplied by the exponent does not
     * contain a decimal.
     *
     * @param decimal a Decimal object
     * @returns a string of the object without a decimal
     */ static verifyNoDecimal(decimal) {
        const integerNumberString = decimal.times(`1e${-((decimal.e || 0) - 15)}`).abs().toString();
        if (integerNumberString.indexOf('.') !== -1) {
            throw new Error('Decimal place found in integerNumberString');
        }
    }
    /**
     * Test if this amount is in units of Native Currency(XRP)
     *
     * @returns true if Native (XRP)
     */ isNative() {
        return (this.bytes[0] & 0x80) === 0 && (this.bytes[0] & 0x20) === 0;
    }
    /**
     * Test if this amount is in units of MPT
     *
     * @returns true if MPT
     */ isMPT() {
        return (this.bytes[0] & 0x80) === 0 && (this.bytes[0] & 0x20) !== 0;
    }
    /**
     * Test if this amount is in units of IOU
     *
     * @returns true if IOU
     */ isIOU() {
        return (this.bytes[0] & 0x80) !== 0;
    }
}
exports.Amount = Amount;
Amount.defaultAmount = new Amount((0, utils_1.hexToBytes)('4000000000000000')); //# sourceMappingURL=amount.js.map
}),
"[project]/node_modules/ripple-binary-codec/dist/types/blob.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Blob = void 0;
const serialized_type_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/types/serialized-type.js [app-ssr] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@xrplf/isomorphic/dist/utils/index.js [app-ssr] (ecmascript)");
/**
 * Variable length encoded type
 */ class Blob extends serialized_type_1.SerializedType {
    constructor(bytes){
        super(bytes);
    }
    /**
     * Defines how to read a Blob from a BinaryParser
     *
     * @param parser The binary parser to read the Blob from
     * @param hint The length of the blob, computed by readVariableLengthLength() and passed in
     * @returns A Blob object
     */ static fromParser(parser, hint) {
        return new Blob(parser.read(hint));
    }
    /**
     * Create a Blob object from a hex-string
     *
     * @param value existing Blob object or a hex-string
     * @returns A Blob object
     */ static from(value) {
        if (value instanceof Blob) {
            return value;
        }
        if (typeof value === 'string') {
            if (!/^[A-F0-9]*$/iu.test(value)) {
                throw new Error('Cannot construct Blob from a non-hex string');
            }
            return new Blob((0, utils_1.hexToBytes)(value));
        }
        throw new Error('Cannot construct Blob from value given');
    }
}
exports.Blob = Blob; //# sourceMappingURL=blob.js.map
}),
"[project]/node_modules/ripple-binary-codec/dist/types/hash-128.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Hash128 = void 0;
const hash_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/types/hash.js [app-ssr] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@xrplf/isomorphic/dist/utils/index.js [app-ssr] (ecmascript)");
/**
 * Hash with a width of 128 bits
 */ class Hash128 extends hash_1.Hash {
    constructor(bytes){
        if (bytes && bytes.byteLength === 0) {
            bytes = Hash128.ZERO_128.bytes;
        }
        super(bytes !== null && bytes !== void 0 ? bytes : Hash128.ZERO_128.bytes);
    }
    /**
     * Get the hex representation of a hash-128 bytes, allowing unset
     *
     * @returns hex String of this.bytes
     */ toHex() {
        const hex = (0, utils_1.bytesToHex)(this.toBytes());
        if (/^0+$/.exec(hex)) {
            return '';
        }
        return hex;
    }
}
exports.Hash128 = Hash128;
Hash128.width = 16;
Hash128.ZERO_128 = new Hash128(new Uint8Array(Hash128.width)); //# sourceMappingURL=hash-128.js.map
}),
"[project]/node_modules/ripple-binary-codec/dist/types/hash-256.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Hash256 = void 0;
const hash_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/types/hash.js [app-ssr] (ecmascript)");
/**
 * Hash with a width of 256 bits
 */ class Hash256 extends hash_1.Hash {
    constructor(bytes){
        super(bytes !== null && bytes !== void 0 ? bytes : Hash256.ZERO_256.bytes);
    }
}
exports.Hash256 = Hash256;
Hash256.width = 32;
Hash256.ZERO_256 = new Hash256(new Uint8Array(Hash256.width)); //# sourceMappingURL=hash-256.js.map
}),
"[project]/node_modules/ripple-binary-codec/dist/types/issue.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Issue = void 0;
const utils_1 = __turbopack_context__.r("[project]/node_modules/@xrplf/isomorphic/dist/utils/index.js [app-ssr] (ecmascript)");
const binary_parser_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/serdes/binary-parser.js [app-ssr] (ecmascript)");
const account_id_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/types/account-id.js [app-ssr] (ecmascript)");
const currency_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/types/currency.js [app-ssr] (ecmascript)");
const serialized_type_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/types/serialized-type.js [app-ssr] (ecmascript)");
const hash_192_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/types/hash-192.js [app-ssr] (ecmascript)");
const utils_2 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/utils.js [app-ssr] (ecmascript)");
/**
 * Type guard for Issue Object
 */ function isIssueObject(arg) {
    const keys = Object.keys(arg).sort();
    const isXRP = keys.length === 1 && keys[0] === 'currency';
    const isIOU = keys.length === 2 && keys[0] === 'currency' && keys[1] === 'issuer';
    const isMPT = keys.length === 1 && keys[0] === 'mpt_issuance_id';
    return isXRP || isIOU || isMPT;
}
const MPT_WIDTH = 44;
const NO_ACCOUNT = account_id_1.AccountID.from('0000000000000000000000000000000000000001');
/**
 * Class for serializing/Deserializing Issue
 */ class Issue extends serialized_type_1.SerializedType {
    constructor(bytes){
        super(bytes !== null && bytes !== void 0 ? bytes : Issue.XRP_ISSUE.bytes);
    }
    /**
     * Construct Issue from XRPIssue, IOUIssue or MPTIssue
     *
     * @param value An object representing an XRPIssue, IOUIssue or MPTIssue
     * @returns An Issue object
     */ static from(value) {
        if (value instanceof Issue) {
            return value;
        }
        if (isIssueObject(value)) {
            if (value.currency) {
                const currency = currency_1.Currency.from(value.currency.toString()).toBytes();
                //IOU case
                if (value.issuer) {
                    const issuer = account_id_1.AccountID.from(value.issuer.toString()).toBytes();
                    return new Issue((0, utils_1.concat)([
                        currency,
                        issuer
                    ]));
                }
                //XRP case
                return new Issue(currency);
            }
            // MPT case
            if (value.mpt_issuance_id) {
                const mptIssuanceIdBytes = hash_192_1.Hash192.from(value.mpt_issuance_id.toString()).toBytes();
                const issuerAccount = mptIssuanceIdBytes.slice(4);
                const sequence = Number((0, utils_2.readUInt32BE)(mptIssuanceIdBytes.slice(0, 4), 0)); // sequence is in Big-endian format in mpt_issuance_id
                // Convert to Little-endian
                const sequenceBuffer = new Uint8Array(4);
                new DataView(sequenceBuffer.buffer).setUint32(0, sequence, true);
                return new Issue((0, utils_1.concat)([
                    issuerAccount,
                    NO_ACCOUNT.toBytes(),
                    sequenceBuffer
                ]));
            }
        }
        throw new Error('Invalid type to construct an Issue');
    }
    /**
     * Read Issue from a BinaryParser
     *
     * @param parser BinaryParser to read the Issue from
     *
     * @returns An Issue object
     */ static fromParser(parser) {
        // XRP
        const currencyOrAccount = parser.read(20);
        if (new currency_1.Currency(currencyOrAccount).toJSON() === 'XRP') {
            return new Issue(currencyOrAccount);
        }
        // MPT
        const issuerAccountId = new account_id_1.AccountID(parser.read(20));
        if (NO_ACCOUNT.toHex() === issuerAccountId.toHex()) {
            const sequence = parser.read(4);
            return new Issue((0, utils_1.concat)([
                currencyOrAccount,
                NO_ACCOUNT.toBytes(),
                sequence
            ]));
        }
        // IOU
        return new Issue((0, utils_1.concat)([
            currencyOrAccount,
            issuerAccountId.toBytes()
        ]));
    }
    /**
     * Get the JSON representation of this IssueObject
     *
     * @returns the JSON interpretation of this.bytes
     */ toJSON() {
        // If the buffer is exactly 44 bytes, treat it as an MPTIssue.
        if (this.toBytes().length === MPT_WIDTH) {
            const issuerAccount = this.toBytes().slice(0, 20);
            const sequence = new DataView(this.toBytes().slice(40).buffer).getUint32(0, true);
            // sequence part of mpt_issuance_id should be in Big-endian
            const sequenceBuffer = new Uint8Array(4);
            (0, utils_2.writeUInt32BE)(sequenceBuffer, sequence, 0);
            return {
                mpt_issuance_id: (0, utils_1.bytesToHex)((0, utils_1.concat)([
                    sequenceBuffer,
                    issuerAccount
                ]))
            };
        }
        const parser = new binary_parser_1.BinaryParser(this.toString());
        const currency = currency_1.Currency.fromParser(parser);
        if (currency.toJSON() === 'XRP') {
            return {
                currency: currency.toJSON()
            };
        }
        const issuer = account_id_1.AccountID.fromParser(parser);
        return {
            currency: currency.toJSON(),
            issuer: issuer.toJSON()
        };
    }
}
exports.Issue = Issue;
Issue.XRP_ISSUE = new Issue(new Uint8Array(20)); //# sourceMappingURL=issue.js.map
}),
"[project]/node_modules/ripple-binary-codec/dist/types/st-number.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.STNumber = void 0;
const serialized_type_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/types/serialized-type.js [app-ssr] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/utils.js [app-ssr] (ecmascript)");
/**
 * Constants for mantissa and exponent normalization per XRPL Number spec.
 * These define allowed magnitude for mantissa and exponent after normalization.
 */ const MIN_MANTISSA = BigInt('1000000000000000');
const MAX_MANTISSA = BigInt('9999999999999999');
const MIN_EXPONENT = -32768;
const MAX_EXPONENT = 32768;
const DEFAULT_VALUE_EXPONENT = -2147483648;
/**
 * Extract mantissa, exponent, and sign from a number string.
 *
 * @param val - The string representing the number (may be integer, decimal, or scientific notation).
 * @returns Object containing mantissa (BigInt), exponent (number), and isNegative (boolean).
 * @throws Error if the string cannot be parsed as a valid number.
 *
 * Examples:
 *   '123'        -> { mantissa: 123n, exponent: 0, isNegative: false }
 *   '-00123.45'  -> { mantissa: -12345n, exponent: -2, isNegative: true }
 *   '+7.1e2'     -> { mantissa: 71n, exponent: -1 + 2 = 1, isNegative: false }
 */ function extractNumberPartsFromString(val) {
    /**
     * Regex for parsing decimal/float/scientific number strings with optional sign, integer, decimal, and exponent parts.
     *
     * Pattern: /^([-+]?)([0-9]+)(?:\.([0-9]+))?(?:[eE]([+-]?[0-9]+))?$/
     *
     * Breakdown:
     *   1. ([-+]?)         - Optional '+' or '-' sign at the start.
     *   2. ([0-9]+)        - Integer part: one or more digits (leading zeros allowed).
     *   3. (?:\.([0-9]+))? - Optional decimal point followed by one or more digits.
     *   4. (?:[eE]([+-]?[0-9]+))? - Optional exponent, starting with 'e' or 'E', optional sign, and digits.
     *
     * Notes:
     *   - Leading zeros are accepted and normalized by code after parsing.
     *   - Empty decimal ('123.') and missing integer ('.456') are NOT matchedmust be fully specified.
     */ // eslint-disable-next-line prefer-named-capture-group
    const regex = /^([-+]?)([0-9]+)(?:\.([0-9]+))?(?:[eE]([+-]?[0-9]+))?$/;
    const match = regex.exec(val);
    if (!match) throw new Error(`Unable to parse number from string: ${val}`);
    const [, sign, intPart, fracPart, expPart] = match;
    // Remove leading zeros (unless the entire intPart is zeros)
    const cleanIntPart = intPart.replace(/^0+(?=\d)/, '') || '0';
    let mantissaStr = cleanIntPart;
    let exponent = 0;
    if (fracPart) {
        mantissaStr += fracPart;
        exponent -= fracPart.length;
    }
    if (expPart) exponent += parseInt(expPart, 10);
    let mantissa = BigInt(mantissaStr);
    if (sign === '-') mantissa = -mantissa;
    const isNegative = mantissa < BigInt(0);
    return {
        mantissa,
        exponent,
        isNegative
    };
}
/**
 * Normalize the mantissa and exponent to XRPL constraints.
 *
 * Ensures that after normalization, the mantissa is between MIN_MANTISSA and MAX_MANTISSA (unless zero).
 * Adjusts the exponent as needed by shifting the mantissa left/right (multiplying/dividing by 10).
 *
 * @param mantissa - The unnormalized mantissa (BigInt).
 * @param exponent - The unnormalized exponent (number).
 * @returns An object with normalized mantissa and exponent.
 * @throws Error if the number cannot be normalized within allowed exponent range.
 */ function normalize(mantissa, exponent) {
    let m = mantissa < BigInt(0) ? -mantissa : mantissa;
    const isNegative = mantissa < BigInt(0);
    while(m !== BigInt(0) && m < MIN_MANTISSA && exponent > MIN_EXPONENT){
        exponent -= 1;
        m *= BigInt(10);
    }
    while(m > MAX_MANTISSA){
        if (exponent >= MAX_EXPONENT) throw new Error('Mantissa and exponent are too large');
        exponent += 1;
        m /= BigInt(10);
    }
    if (isNegative) m = -m;
    return {
        mantissa: m,
        exponent
    };
}
/**
 * STNumber: Encodes XRPL's "Number" type.
 *
 * - Always encoded as 12 bytes: 8-byte signed mantissa, 4-byte signed exponent, both big-endian.
 * - Can only be constructed from a valid number string or another STNumber instance.
 *
 * Usage:
 *   STNumber.from("1.2345e5")
 *   STNumber.from("-123")
 *   STNumber.fromParser(parser)
 */ class STNumber extends serialized_type_1.SerializedType {
    /**
     * Construct a STNumber from 12 bytes (8 for mantissa, 4 for exponent).
     * @param bytes - 12-byte Uint8Array
     * @throws Error if input is not a Uint8Array of length 12.
     */ constructor(bytes){
        const used = bytes !== null && bytes !== void 0 ? bytes : STNumber.defaultBytes;
        if (!(used instanceof Uint8Array) || used.length !== 12) {
            throw new Error(`STNumber must be constructed from a 12-byte Uint8Array, got ${used === null || used === void 0 ? void 0 : used.length}`);
        }
        super(used);
    }
    /**
     * Construct from a number string (or another STNumber).
     *
     * @param value - A string, or STNumber instance.
     * @returns STNumber instance.
     * @throws Error if not a string or STNumber.
     */ static from(value) {
        if (value instanceof STNumber) {
            return value;
        }
        if (typeof value === 'string') {
            return STNumber.fromValue(value);
        }
        throw new Error('STNumber.from: Only string or STNumber instance is supported');
    }
    /**
     * Construct from a number string (integer, decimal, or scientific notation).
     * Handles normalization to XRPL Number constraints.
     *
     * @param val - The number as a string (e.g. '1.23', '-123e5').
     * @returns STNumber instance
     * @throws Error if val is not a valid number string.
     */ static fromValue(val) {
        const { mantissa, exponent, isNegative } = extractNumberPartsFromString(val);
        let normalizedMantissa;
        let normalizedExponent;
        if (mantissa === BigInt(0) && exponent === 0 && !isNegative) {
            normalizedMantissa = BigInt(0);
            normalizedExponent = DEFAULT_VALUE_EXPONENT;
        } else {
            ;
            ({ mantissa: normalizedMantissa, exponent: normalizedExponent } = normalize(mantissa, exponent));
        }
        const bytes = new Uint8Array(12);
        (0, utils_1.writeInt64BE)(bytes, normalizedMantissa, 0);
        (0, utils_1.writeInt32BE)(bytes, normalizedExponent, 8);
        return new STNumber(bytes);
    }
    /**
     * Read a STNumber from a BinaryParser stream (12 bytes).
     * @param parser - BinaryParser positioned at the start of a number
     * @returns STNumber instance
     */ static fromParser(parser) {
        return new STNumber(parser.read(12));
    }
    /**
     * Convert this STNumber to a normalized string representation.
     * The output is decimal or scientific notation, depending on exponent range.
     * Follows XRPL convention: zero is "0", other values are normalized to a canonical string.
     *
     * @returns String representation of the value
     */ // eslint-disable-next-line complexity -- required
    toJSON() {
        const b = this.bytes;
        if (!b || b.length !== 12) throw new Error('STNumber internal bytes not set or wrong length');
        // Signed 64-bit mantissa
        const mantissa = (0, utils_1.readInt64BE)(b, 0);
        // Signed 32-bit exponent
        const exponent = (0, utils_1.readInt32BE)(b, 8);
        // Special zero: XRPL encodes canonical zero as mantissa=0, exponent=DEFAULT_VALUE_EXPONENT.
        if (mantissa === BigInt(0) && exponent === DEFAULT_VALUE_EXPONENT) {
            return '0';
        }
        if (exponent === 0) return mantissa.toString();
        // Use scientific notation for small/large exponents, decimal otherwise
        if (exponent < -25 || exponent > -5) {
            return `${mantissa}e${exponent}`;
        }
        // Decimal rendering for -25 <= exp <= -5
        const isNegative = mantissa < BigInt(0);
        const mantissaAbs = mantissa < BigInt(0) ? -mantissa : mantissa;
        const padPrefix = 27;
        const padSuffix = 23;
        const mantissaStr = mantissaAbs.toString();
        const rawValue = '0'.repeat(padPrefix) + mantissaStr + '0'.repeat(padSuffix);
        const OFFSET = exponent + 43;
        const integerPart = rawValue.slice(0, OFFSET).replace(/^0+/, '') || '0';
        const fractionPart = rawValue.slice(OFFSET).replace(/0+$/, '');
        return `${isNegative ? '-' : ''}${integerPart}${fractionPart ? '.' + fractionPart : ''}`;
    }
}
exports.STNumber = STNumber;
/** 12 zero bytes, represents canonical zero. */ STNumber.defaultBytes = new Uint8Array(12); //# sourceMappingURL=st-number.js.map
}),
"[project]/node_modules/ripple-binary-codec/dist/types/path-set.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PathSet = void 0;
const account_id_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/types/account-id.js [app-ssr] (ecmascript)");
const currency_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/types/currency.js [app-ssr] (ecmascript)");
const binary_parser_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/serdes/binary-parser.js [app-ssr] (ecmascript)");
const serialized_type_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/types/serialized-type.js [app-ssr] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@xrplf/isomorphic/dist/utils/index.js [app-ssr] (ecmascript)");
/**
 * Constants for separating Paths in a PathSet
 */ const PATHSET_END_BYTE = 0x00;
const PATH_SEPARATOR_BYTE = 0xff;
/**
 * Constant for masking types of a Hop
 */ const TYPE_ACCOUNT = 0x01;
const TYPE_CURRENCY = 0x10;
const TYPE_ISSUER = 0x20;
/**
 * TypeGuard for HopObject
 */ function isHopObject(arg) {
    return arg.issuer !== undefined || arg.account !== undefined || arg.currency !== undefined;
}
/**
 * TypeGuard for PathSet
 */ function isPathSet(arg) {
    return Array.isArray(arg) && arg.length === 0 || Array.isArray(arg) && Array.isArray(arg[0]) && arg[0].length === 0 || Array.isArray(arg) && Array.isArray(arg[0]) && isHopObject(arg[0][0]);
}
/**
 * Serialize and Deserialize a Hop
 */ class Hop extends serialized_type_1.SerializedType {
    /**
     * Create a Hop from a HopObject
     *
     * @param value Either a hop or HopObject to create a hop with
     * @returns a Hop
     */ static from(value) {
        if (value instanceof Hop) {
            return value;
        }
        const bytes = [
            Uint8Array.from([
                0
            ])
        ];
        if (value.account) {
            bytes.push(account_id_1.AccountID.from(value.account).toBytes());
            bytes[0][0] |= TYPE_ACCOUNT;
        }
        if (value.currency) {
            bytes.push(currency_1.Currency.from(value.currency).toBytes());
            bytes[0][0] |= TYPE_CURRENCY;
        }
        if (value.issuer) {
            bytes.push(account_id_1.AccountID.from(value.issuer).toBytes());
            bytes[0][0] |= TYPE_ISSUER;
        }
        return new Hop((0, utils_1.concat)(bytes));
    }
    /**
     * Construct a Hop from a BinaryParser
     *
     * @param parser BinaryParser to read the Hop from
     * @returns a Hop
     */ static fromParser(parser) {
        const type = parser.readUInt8();
        const bytes = [
            Uint8Array.from([
                type
            ])
        ];
        if (type & TYPE_ACCOUNT) {
            bytes.push(parser.read(account_id_1.AccountID.width));
        }
        if (type & TYPE_CURRENCY) {
            bytes.push(parser.read(currency_1.Currency.width));
        }
        if (type & TYPE_ISSUER) {
            bytes.push(parser.read(account_id_1.AccountID.width));
        }
        return new Hop((0, utils_1.concat)(bytes));
    }
    /**
     * Get the JSON interpretation of this hop
     *
     * @returns a HopObject, an JS object with optional account, issuer, and currency
     */ toJSON() {
        const hopParser = new binary_parser_1.BinaryParser((0, utils_1.bytesToHex)(this.bytes));
        const type = hopParser.readUInt8();
        let account, currency, issuer;
        if (type & TYPE_ACCOUNT) {
            account = account_id_1.AccountID.fromParser(hopParser).toJSON();
        }
        if (type & TYPE_CURRENCY) {
            currency = currency_1.Currency.fromParser(hopParser).toJSON();
        }
        if (type & TYPE_ISSUER) {
            issuer = account_id_1.AccountID.fromParser(hopParser).toJSON();
        }
        const result = {};
        if (account) {
            result.account = account;
        }
        if (issuer) {
            result.issuer = issuer;
        }
        if (currency) {
            result.currency = currency;
        }
        return result;
    }
    /**
     * get a number representing the type of this hop
     *
     * @returns a number to be bitwise and-ed with TYPE_ constants to describe the types in the hop
     */ type() {
        return this.bytes[0];
    }
}
/**
 * Class for serializing/deserializing Paths
 */ class Path extends serialized_type_1.SerializedType {
    /**
     * construct a Path from an array of Hops
     *
     * @param value Path or array of HopObjects to construct a Path
     * @returns the Path
     */ static from(value) {
        if (value instanceof Path) {
            return value;
        }
        const bytes = [];
        value.forEach((hop)=>{
            bytes.push(Hop.from(hop).toBytes());
        });
        return new Path((0, utils_1.concat)(bytes));
    }
    /**
     * Read a Path from a BinaryParser
     *
     * @param parser BinaryParser to read Path from
     * @returns the Path represented by the bytes read from the BinaryParser
     */ static fromParser(parser) {
        const bytes = [];
        while(!parser.end()){
            bytes.push(Hop.fromParser(parser).toBytes());
            if (parser.peek() === PATHSET_END_BYTE || parser.peek() === PATH_SEPARATOR_BYTE) {
                break;
            }
        }
        return new Path((0, utils_1.concat)(bytes));
    }
    /**
     * Get the JSON representation of this Path
     *
     * @returns an Array of HopObject constructed from this.bytes
     */ toJSON() {
        const json = [];
        const pathParser = new binary_parser_1.BinaryParser(this.toString());
        while(!pathParser.end()){
            json.push(Hop.fromParser(pathParser).toJSON());
        }
        return json;
    }
}
/**
 * Deserialize and Serialize the PathSet type
 */ class PathSet extends serialized_type_1.SerializedType {
    /**
     * Construct a PathSet from an Array of Arrays representing paths
     *
     * @param value A PathSet or Array of Array of HopObjects
     * @returns the PathSet constructed from value
     */ static from(value) {
        if (value instanceof PathSet) {
            return value;
        }
        if (isPathSet(value)) {
            const bytes = [];
            value.forEach((path)=>{
                bytes.push(Path.from(path).toBytes());
                bytes.push(Uint8Array.from([
                    PATH_SEPARATOR_BYTE
                ]));
            });
            bytes[bytes.length - 1] = Uint8Array.from([
                PATHSET_END_BYTE
            ]);
            return new PathSet((0, utils_1.concat)(bytes));
        }
        throw new Error('Cannot construct PathSet from given value');
    }
    /**
     * Construct a PathSet from a BinaryParser
     *
     * @param parser A BinaryParser to read PathSet from
     * @returns the PathSet read from parser
     */ static fromParser(parser) {
        const bytes = [];
        while(!parser.end()){
            bytes.push(Path.fromParser(parser).toBytes());
            bytes.push(parser.read(1));
            if (bytes[bytes.length - 1][0] == PATHSET_END_BYTE) {
                break;
            }
        }
        return new PathSet((0, utils_1.concat)(bytes));
    }
    /**
     * Get the JSON representation of this PathSet
     *
     * @returns an Array of Array of HopObjects, representing this PathSet
     */ toJSON() {
        const json = [];
        const pathParser = new binary_parser_1.BinaryParser(this.toString());
        while(!pathParser.end()){
            json.push(Path.fromParser(pathParser).toJSON());
            pathParser.skip(1);
        }
        return json;
    }
}
exports.PathSet = PathSet; //# sourceMappingURL=path-set.js.map
}),
"[project]/node_modules/ripple-binary-codec/dist/types/uint.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.UInt = void 0;
const serialized_type_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/types/serialized-type.js [app-ssr] (ecmascript)");
/**
 * Compare numbers and bigInts n1 and n2
 *
 * @param n1 First object to compare
 * @param n2 Second object to compare
 * @returns -1, 0, or 1, depending on how the two objects compare
 */ function compare(n1, n2) {
    return n1 < n2 ? -1 : n1 == n2 ? 0 : 1;
}
/**
 * Base class for serializing and deserializing unsigned integers.
 */ class UInt extends serialized_type_1.Comparable {
    constructor(bytes){
        super(bytes);
    }
    /**
     * Overload of compareTo for Comparable
     *
     * @param other other UInt to compare this to
     * @returns -1, 0, or 1 depending on how the objects relate to each other
     */ compareTo(other) {
        return compare(this.valueOf(), other.valueOf());
    }
    /**
     * Convert a UInt object to JSON
     *
     * @returns number or string represented by this.bytes
     */ toJSON() {
        const val = this.valueOf();
        return typeof val === 'number' ? val : val.toString();
    }
    static checkUintRange(val, min, max) {
        if (val < min || val > max) {
            throw new Error(`Invalid ${this.constructor.name}: ${val} must be >= ${min} and <= ${max}`);
        }
    }
}
exports.UInt = UInt; //# sourceMappingURL=uint.js.map
}),
"[project]/node_modules/ripple-binary-codec/dist/types/uint-64.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.UInt64 = void 0;
const uint_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/types/uint.js [app-ssr] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@xrplf/isomorphic/dist/utils/index.js [app-ssr] (ecmascript)");
const utils_2 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/utils.js [app-ssr] (ecmascript)");
const enums_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/enums/index.js [app-ssr] (ecmascript)");
const HEX_REGEX = /^[a-fA-F0-9]{1,16}$/;
const BASE10_REGEX = /^[0-9]{1,20}$/;
const mask = BigInt(0x00000000ffffffff);
const BASE10_AMOUNT_FIELDS = new Set([
    'MaximumAmount',
    'OutstandingAmount',
    'MPTAmount',
    'LockedAmount'
]);
function isBase10(fieldName) {
    return BASE10_AMOUNT_FIELDS.has(fieldName);
}
/**
 * Derived UInt class for serializing/deserializing 64 bit UInt
 */ class UInt64 extends uint_1.UInt {
    constructor(bytes){
        super(bytes !== null && bytes !== void 0 ? bytes : UInt64.defaultUInt64.bytes);
    }
    static fromParser(parser) {
        return new UInt64(parser.read(UInt64.width));
    }
    /**
     * Construct a UInt64 object
     *
     * @param val A UInt64, hex-string, bigInt, or number
     * @returns A UInt64 object
     */ // eslint-disable-next-line complexity
    static from(val, fieldName = '') {
        if (val instanceof UInt64) {
            return val;
        }
        let buf = new Uint8Array(UInt64.width);
        if (typeof val === 'number') {
            if (val < 0) {
                throw new Error('value must be an unsigned integer');
            }
            const number = BigInt(val);
            const intBuf = [
                new Uint8Array(4),
                new Uint8Array(4)
            ];
            (0, utils_2.writeUInt32BE)(intBuf[0], Number(number >> BigInt(32)), 0);
            (0, utils_2.writeUInt32BE)(intBuf[1], Number(number & BigInt(mask)), 0);
            return new UInt64((0, utils_1.concat)(intBuf));
        }
        if (typeof val === 'string') {
            if (isBase10(fieldName)) {
                if (!BASE10_REGEX.test(val)) {
                    throw new Error(`${fieldName} ${val} is not a valid base 10 string`);
                }
                val = BigInt(val).toString(16);
            }
            if (typeof val === 'string' && !HEX_REGEX.test(val)) {
                throw new Error(`${val} is not a valid hex-string`);
            }
            const strBuf = val.padStart(16, '0');
            buf = (0, utils_1.hexToBytes)(strBuf);
            return new UInt64(buf);
        }
        if (typeof val === 'bigint') {
            const intBuf = [
                new Uint8Array(4),
                new Uint8Array(4)
            ];
            (0, utils_2.writeUInt32BE)(intBuf[0], Number(Number(val >> BigInt(32))), 0);
            (0, utils_2.writeUInt32BE)(intBuf[1], Number(val & BigInt(mask)), 0);
            return new UInt64((0, utils_1.concat)(intBuf));
        }
        throw new Error('Cannot construct UInt64 from given value');
    }
    /**
     * The JSON representation of a UInt64 object
     *
     * @returns a hex-string
     */ toJSON(_definitions = enums_1.DEFAULT_DEFINITIONS, fieldName = '') {
        const hexString = (0, utils_1.bytesToHex)(this.bytes);
        if (isBase10(fieldName)) {
            return BigInt('0x' + hexString).toString(10);
        }
        return hexString;
    }
    /**
     * Get the value of the UInt64
     *
     * @returns the number represented buy this.bytes
     */ valueOf() {
        const msb = BigInt((0, utils_2.readUInt32BE)(this.bytes.slice(0, 4), 0));
        const lsb = BigInt((0, utils_2.readUInt32BE)(this.bytes.slice(4), 0));
        return msb << BigInt(32) | lsb;
    }
    /**
     * Get the bytes representation of the UInt64 object
     *
     * @returns 8 bytes representing the UInt64
     */ toBytes() {
        return this.bytes;
    }
}
exports.UInt64 = UInt64;
UInt64.width = 64 / 8; // 8
UInt64.defaultUInt64 = new UInt64(new Uint8Array(UInt64.width)); //# sourceMappingURL=uint-64.js.map
}),
"[project]/node_modules/ripple-binary-codec/dist/types/st-object.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.STObject = void 0;
const enums_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/enums/index.js [app-ssr] (ecmascript)");
const serialized_type_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/types/serialized-type.js [app-ssr] (ecmascript)");
const ripple_address_codec_1 = __turbopack_context__.r("[project]/node_modules/ripple-address-codec/dist/index.js [app-ssr] (ecmascript)");
const binary_parser_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/serdes/binary-parser.js [app-ssr] (ecmascript)");
const binary_serializer_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/serdes/binary-serializer.js [app-ssr] (ecmascript)");
const st_array_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/types/st-array.js [app-ssr] (ecmascript)");
const uint_64_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/types/uint-64.js [app-ssr] (ecmascript)");
const OBJECT_END_MARKER_BYTE = Uint8Array.from([
    0xe1
]);
const OBJECT_END_MARKER = 'ObjectEndMarker';
const ST_OBJECT = 'STObject';
const DESTINATION = 'Destination';
const ACCOUNT = 'Account';
const SOURCE_TAG = 'SourceTag';
const DEST_TAG = 'DestinationTag';
/**
 * Break down an X-Address into an account and a tag
 *
 * @param field Name of field
 * @param xAddress X-Address corresponding to the field
 */ function handleXAddress(field, xAddress) {
    const decoded = (0, ripple_address_codec_1.xAddressToClassicAddress)(xAddress);
    let tagName;
    if (field === DESTINATION) tagName = DEST_TAG;
    else if (field === ACCOUNT) tagName = SOURCE_TAG;
    else if (decoded.tag !== false) throw new Error(`${field} cannot have an associated tag`);
    return decoded.tag !== false ? {
        [field]: decoded.classicAddress,
        [tagName]: decoded.tag
    } : {
        [field]: decoded.classicAddress
    };
}
/**
 * Validate that two objects don't both have the same tag fields
 *
 * @param obj1 First object to check for tags
 * @param obj2 Second object to check for tags
 * @throws When both objects have SourceTag or DestinationTag
 */ function checkForDuplicateTags(obj1, obj2) {
    if (!(obj1[SOURCE_TAG] === undefined || obj2[SOURCE_TAG] === undefined)) throw new Error('Cannot have Account X-Address and SourceTag');
    if (!(obj1[DEST_TAG] === undefined || obj2[DEST_TAG] === undefined)) throw new Error('Cannot have Destination X-Address and DestinationTag');
}
/**
 * Class for Serializing/Deserializing objects
 */ class STObject extends serialized_type_1.SerializedType {
    /**
     * Construct a STObject from a BinaryParser
     *
     * @param parser BinaryParser to read STObject from
     * @returns A STObject object
     */ static fromParser(parser) {
        const list = new binary_serializer_1.BytesList();
        const bytes = new binary_serializer_1.BinarySerializer(list);
        while(!parser.end()){
            const field = parser.readField();
            if (field.name === OBJECT_END_MARKER) {
                break;
            }
            const associatedValue = parser.readFieldValue(field);
            bytes.writeFieldAndValue(field, associatedValue);
            if (field.type.name === ST_OBJECT) {
                bytes.put(OBJECT_END_MARKER_BYTE);
            }
        }
        return new STObject(list.toBytes());
    }
    /**
     * Construct a STObject from a JSON object
     *
     * @param value An object to include
     * @param filter optional, denote which field to include in serialized object
     * @param definitions optional, types and values to use to encode/decode a transaction
     * @returns a STObject object
     */ static from(value, filter, definitions = enums_1.DEFAULT_DEFINITIONS) {
        if (value instanceof STObject) {
            return value;
        }
        const list = new binary_serializer_1.BytesList();
        const bytes = new binary_serializer_1.BinarySerializer(list);
        let isUnlModify = false;
        const xAddressDecoded = Object.entries(value).reduce((acc, [key, val])=>{
            let handled = undefined;
            if (val && (0, ripple_address_codec_1.isValidXAddress)(val.toString())) {
                handled = handleXAddress(key, val.toString());
                checkForDuplicateTags(handled, value);
            }
            return Object.assign(acc, handled !== null && handled !== void 0 ? handled : {
                [key]: val
            });
        }, {});
        function isValidFieldInstance(f) {
            return f !== undefined && xAddressDecoded[f.name] !== undefined && f.isSerialized;
        }
        let sorted = Object.keys(xAddressDecoded).map((f)=>{
            if (!(f in definitions.field)) {
                if (f[0] === f[0].toLowerCase()) return undefined;
                throw new Error(`Field ${f} is not defined in the definitions`);
            }
            return definitions.field[f];
        }).filter(isValidFieldInstance).sort((a, b)=>{
            return a.ordinal - b.ordinal;
        });
        if (filter !== undefined) {
            sorted = sorted.filter(filter);
        }
        sorted.forEach((field)=>{
            const associatedValue = field.type.name === ST_OBJECT ? this.from(xAddressDecoded[field.name], undefined, definitions) : field.type.name === 'STArray' ? st_array_1.STArray.from(xAddressDecoded[field.name], definitions) : field.type.name === 'UInt64' ? uint_64_1.UInt64.from(xAddressDecoded[field.name], field.name) : field.associatedType.from(xAddressDecoded[field.name]);
            if (associatedValue == undefined) {
                throw new TypeError(`Unable to interpret "${field.name}: ${xAddressDecoded[field.name]}".`);
            }
            if (associatedValue.name === 'UNLModify') {
                // triggered when the TransactionType field has a value of 'UNLModify'
                isUnlModify = true;
            }
            // true when in the UNLModify pseudotransaction (after the transaction type has been processed) and working with the
            // Account field
            // The Account field must not be a part of the UNLModify pseudotransaction encoding, due to a bug in rippled
            const isUnlModifyWorkaround = field.name == 'Account' && isUnlModify;
            bytes.writeFieldAndValue(field, associatedValue, isUnlModifyWorkaround);
            if (field.type.name === ST_OBJECT) {
                bytes.put(OBJECT_END_MARKER_BYTE);
            }
        });
        return new STObject(list.toBytes());
    }
    /**
     * Get the JSON interpretation of this.bytes
     * @param definitions rippled definitions used to parse the values of transaction types and such.
     *                          Can be customized for sidechains and amendments.
     * @returns a JSON object
     */ toJSON(definitions) {
        const objectParser = new binary_parser_1.BinaryParser(this.toString(), definitions);
        const accumulator = {};
        while(!objectParser.end()){
            const field = objectParser.readField();
            if (field.name === OBJECT_END_MARKER) {
                break;
            }
            accumulator[field.name] = objectParser.readFieldValue(field).toJSON(definitions, field.name);
        }
        return accumulator;
    }
}
exports.STObject = STObject; //# sourceMappingURL=st-object.js.map
}),
"[project]/node_modules/ripple-binary-codec/dist/types/st-array.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.STArray = void 0;
const enums_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/enums/index.js [app-ssr] (ecmascript)");
const serialized_type_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/types/serialized-type.js [app-ssr] (ecmascript)");
const st_object_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/types/st-object.js [app-ssr] (ecmascript)");
const binary_parser_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/serdes/binary-parser.js [app-ssr] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@xrplf/isomorphic/dist/utils/index.js [app-ssr] (ecmascript)");
const ARRAY_END_MARKER = Uint8Array.from([
    0xf1
]);
const ARRAY_END_MARKER_NAME = 'ArrayEndMarker';
const OBJECT_END_MARKER = Uint8Array.from([
    0xe1
]);
/**
 * TypeGuard for Array<JsonObject>
 */ function isObjects(args) {
    return Array.isArray(args) && args.every((arg)=>typeof arg === 'object' && Object.keys(arg).length === 1 && typeof Object.values(arg)[0] === 'object');
}
/**
 * Class for serializing and deserializing Arrays of Objects
 */ class STArray extends serialized_type_1.SerializedType {
    /**
     * Construct an STArray from a BinaryParser
     *
     * @param parser BinaryParser to parse an STArray from
     * @returns An STArray Object
     */ static fromParser(parser) {
        const bytes = [];
        while(!parser.end()){
            const field = parser.readField();
            if (field.name === ARRAY_END_MARKER_NAME) {
                break;
            }
            bytes.push(field.header, parser.readFieldValue(field).toBytes(), OBJECT_END_MARKER);
        }
        bytes.push(ARRAY_END_MARKER);
        return new STArray((0, utils_1.concat)(bytes));
    }
    /**
     * Construct an STArray from an Array of JSON Objects
     *
     * @param value STArray or Array of Objects to parse into an STArray
     * @param definitions optional, types and values to use to encode/decode a transaction
     * @returns An STArray object
     */ static from(value, definitions = enums_1.DEFAULT_DEFINITIONS) {
        if (value instanceof STArray) {
            return value;
        }
        if (isObjects(value)) {
            const bytes = [];
            value.forEach((obj)=>{
                bytes.push(st_object_1.STObject.from(obj, undefined, definitions).toBytes());
            });
            bytes.push(ARRAY_END_MARKER);
            return new STArray((0, utils_1.concat)(bytes));
        }
        throw new Error('Cannot construct STArray from value given');
    }
    /**
     * Return the JSON representation of this.bytes
     *
     * @param definitions optional, types and values to use to encode/decode a transaction
     * @returns An Array of JSON objects
     */ toJSON(definitions = enums_1.DEFAULT_DEFINITIONS) {
        const result = [];
        const arrayParser = new binary_parser_1.BinaryParser(this.toString(), definitions);
        while(!arrayParser.end()){
            const field = arrayParser.readField();
            if (field.name === ARRAY_END_MARKER_NAME) {
                break;
            }
            const outer = {};
            outer[field.name] = st_object_1.STObject.fromParser(arrayParser).toJSON(definitions);
            result.push(outer);
        }
        return result;
    }
}
exports.STArray = STArray; //# sourceMappingURL=st-array.js.map
}),
"[project]/node_modules/ripple-binary-codec/dist/types/uint-16.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.UInt16 = void 0;
const uint_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/types/uint.js [app-ssr] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/utils.js [app-ssr] (ecmascript)");
/**
 * Derived UInt class for serializing/deserializing 16 bit UInt
 */ class UInt16 extends uint_1.UInt {
    constructor(bytes){
        super(bytes !== null && bytes !== void 0 ? bytes : UInt16.defaultUInt16.bytes);
    }
    static fromParser(parser) {
        return new UInt16(parser.read(UInt16.width));
    }
    /**
     * Construct a UInt16 object from a number
     *
     * @param val UInt16 object or number
     */ static from(val) {
        if (val instanceof UInt16) {
            return val;
        }
        if (typeof val === 'number') {
            UInt16.checkUintRange(val, 0, 0xffff);
            const buf = new Uint8Array(UInt16.width);
            (0, utils_1.writeUInt16BE)(buf, val, 0);
            return new UInt16(buf);
        }
        throw new Error('Can not construct UInt16 with given value');
    }
    /**
     * get the value of a UInt16 object
     *
     * @returns the number represented by this.bytes
     */ valueOf() {
        return parseInt((0, utils_1.readUInt16BE)(this.bytes, 0));
    }
}
exports.UInt16 = UInt16;
UInt16.width = 16 / 8; // 2
UInt16.defaultUInt16 = new UInt16(new Uint8Array(UInt16.width)); //# sourceMappingURL=uint-16.js.map
}),
"[project]/node_modules/ripple-binary-codec/dist/types/uint-32.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.UInt32 = void 0;
const uint_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/types/uint.js [app-ssr] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/utils.js [app-ssr] (ecmascript)");
/**
 * Derived UInt class for serializing/deserializing 32 bit UInt
 */ class UInt32 extends uint_1.UInt {
    constructor(bytes){
        super(bytes !== null && bytes !== void 0 ? bytes : UInt32.defaultUInt32.bytes);
    }
    static fromParser(parser) {
        return new UInt32(parser.read(UInt32.width));
    }
    /**
     * Construct a UInt32 object from a number
     *
     * @param val UInt32 object or number
     */ static from(val) {
        if (val instanceof UInt32) {
            return val;
        }
        const buf = new Uint8Array(UInt32.width);
        if (typeof val === 'string') {
            const num = Number.parseInt(val);
            (0, utils_1.writeUInt32BE)(buf, num, 0);
            return new UInt32(buf);
        }
        if (typeof val === 'number') {
            UInt32.checkUintRange(val, 0, 0xffffffff);
            (0, utils_1.writeUInt32BE)(buf, val, 0);
            return new UInt32(buf);
        }
        throw new Error('Cannot construct UInt32 from given value');
    }
    /**
     * get the value of a UInt32 object
     *
     * @returns the number represented by this.bytes
     */ valueOf() {
        return parseInt((0, utils_1.readUInt32BE)(this.bytes, 0), 10);
    }
}
exports.UInt32 = UInt32;
UInt32.width = 32 / 8; // 4
UInt32.defaultUInt32 = new UInt32(new Uint8Array(UInt32.width)); //# sourceMappingURL=uint-32.js.map
}),
"[project]/node_modules/ripple-binary-codec/dist/types/uint-8.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.UInt8 = void 0;
const uint_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/types/uint.js [app-ssr] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@xrplf/isomorphic/dist/utils/index.js [app-ssr] (ecmascript)");
const utils_2 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/utils.js [app-ssr] (ecmascript)");
/**
 * Derived UInt class for serializing/deserializing 8 bit UInt
 */ class UInt8 extends uint_1.UInt {
    constructor(bytes){
        super(bytes !== null && bytes !== void 0 ? bytes : UInt8.defaultUInt8.bytes);
    }
    static fromParser(parser) {
        return new UInt8(parser.read(UInt8.width));
    }
    /**
     * Construct a UInt8 object from a number
     *
     * @param val UInt8 object or number
     */ static from(val) {
        if (val instanceof UInt8) {
            return val;
        }
        if (typeof val === 'number') {
            UInt8.checkUintRange(val, 0, 0xff);
            const buf = new Uint8Array(UInt8.width);
            (0, utils_2.writeUInt8)(buf, val, 0);
            return new UInt8(buf);
        }
        throw new Error('Cannot construct UInt8 from given value');
    }
    /**
     * get the value of a UInt8 object
     *
     * @returns the number represented by this.bytes
     */ valueOf() {
        return parseInt((0, utils_1.bytesToHex)(this.bytes), 16);
    }
}
exports.UInt8 = UInt8;
UInt8.width = 8 / 8; // 1
UInt8.defaultUInt8 = new UInt8(new Uint8Array(UInt8.width)); //# sourceMappingURL=uint-8.js.map
}),
"[project]/node_modules/ripple-binary-codec/dist/types/vector-256.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Vector256 = void 0;
const serialized_type_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/types/serialized-type.js [app-ssr] (ecmascript)");
const hash_256_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/types/hash-256.js [app-ssr] (ecmascript)");
const binary_serializer_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/serdes/binary-serializer.js [app-ssr] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@xrplf/isomorphic/dist/utils/index.js [app-ssr] (ecmascript)");
/**
 * TypeGuard for Array<string>
 */ function isStrings(arg) {
    return Array.isArray(arg) && (arg.length === 0 || typeof arg[0] === 'string');
}
/**
 * Class for serializing and deserializing vectors of Hash256
 */ class Vector256 extends serialized_type_1.SerializedType {
    constructor(bytes){
        super(bytes);
    }
    /**
     * Construct a Vector256 from a BinaryParser
     *
     * @param parser BinaryParser to
     * @param hint length of the vector, in bytes, optional
     * @returns a Vector256 object
     */ static fromParser(parser, hint) {
        const bytesList = new binary_serializer_1.BytesList();
        const bytes = hint !== null && hint !== void 0 ? hint : parser.size();
        const hashes = bytes / 32;
        for(let i = 0; i < hashes; i++){
            hash_256_1.Hash256.fromParser(parser).toBytesSink(bytesList);
        }
        return new Vector256(bytesList.toBytes());
    }
    /**
     * Construct a Vector256 object from an array of hashes
     *
     * @param value A Vector256 object or array of hex-strings representing Hash256's
     * @returns a Vector256 object
     */ static from(value) {
        if (value instanceof Vector256) {
            return value;
        }
        if (isStrings(value)) {
            const bytesList = new binary_serializer_1.BytesList();
            value.forEach((hash)=>{
                hash_256_1.Hash256.from(hash).toBytesSink(bytesList);
            });
            return new Vector256(bytesList.toBytes());
        }
        throw new Error('Cannot construct Vector256 from given value');
    }
    /**
     * Return an Array of hex-strings represented by this.bytes
     *
     * @returns An Array of strings representing the Hash256 objects
     */ toJSON() {
        if (this.bytes.byteLength % 32 !== 0) {
            throw new Error('Invalid bytes for Vector256');
        }
        const result = [];
        for(let i = 0; i < this.bytes.byteLength; i += 32){
            result.push((0, utils_1.bytesToHex)(this.bytes.slice(i, i + 32)));
        }
        return result;
    }
}
exports.Vector256 = Vector256; //# sourceMappingURL=vector-256.js.map
}),
"[project]/node_modules/ripple-binary-codec/dist/types/xchain-bridge.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.XChainBridge = void 0;
const binary_parser_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/serdes/binary-parser.js [app-ssr] (ecmascript)");
const account_id_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/types/account-id.js [app-ssr] (ecmascript)");
const serialized_type_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/types/serialized-type.js [app-ssr] (ecmascript)");
const issue_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/types/issue.js [app-ssr] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@xrplf/isomorphic/dist/utils/index.js [app-ssr] (ecmascript)");
/**
 * Type guard for XChainBridgeObject
 */ function isXChainBridgeObject(arg) {
    const keys = Object.keys(arg).sort();
    return keys.length === 4 && keys[0] === 'IssuingChainDoor' && keys[1] === 'IssuingChainIssue' && keys[2] === 'LockingChainDoor' && keys[3] === 'LockingChainIssue';
}
/**
 * Class for serializing/deserializing XChainBridges
 */ class XChainBridge extends serialized_type_1.SerializedType {
    constructor(bytes){
        super(bytes !== null && bytes !== void 0 ? bytes : XChainBridge.ZERO_XCHAIN_BRIDGE.bytes);
    }
    /**
     * Construct a cross-chain bridge from a JSON
     *
     * @param value XChainBridge or JSON to parse into an XChainBridge
     * @returns An XChainBridge object
     */ static from(value) {
        if (value instanceof XChainBridge) {
            return value;
        }
        if (!isXChainBridgeObject(value)) {
            throw new Error('Invalid type to construct an XChainBridge');
        }
        const bytes = [];
        this.TYPE_ORDER.forEach((item)=>{
            const { name, type } = item;
            if (type === account_id_1.AccountID) {
                bytes.push(Uint8Array.from([
                    0x14
                ]));
            }
            const object = type.from(value[name]);
            bytes.push(object.toBytes());
        });
        return new XChainBridge((0, utils_1.concat)(bytes));
    }
    /**
     * Read an XChainBridge from a BinaryParser
     *
     * @param parser BinaryParser to read the XChainBridge from
     * @returns An XChainBridge object
     */ static fromParser(parser) {
        const bytes = [];
        this.TYPE_ORDER.forEach((item)=>{
            const { type } = item;
            if (type === account_id_1.AccountID) {
                parser.skip(1);
                bytes.push(Uint8Array.from([
                    0x14
                ]));
            }
            const object = type.fromParser(parser);
            bytes.push(object.toBytes());
        });
        return new XChainBridge((0, utils_1.concat)(bytes));
    }
    /**
     * Get the JSON representation of this XChainBridge
     *
     * @returns the JSON interpretation of this.bytes
     */ toJSON() {
        const parser = new binary_parser_1.BinaryParser(this.toString());
        const json = {};
        XChainBridge.TYPE_ORDER.forEach((item)=>{
            const { name, type } = item;
            if (type === account_id_1.AccountID) {
                parser.skip(1);
            }
            const object = type.fromParser(parser).toJSON();
            json[name] = object;
        });
        return json;
    }
}
exports.XChainBridge = XChainBridge;
XChainBridge.ZERO_XCHAIN_BRIDGE = new XChainBridge((0, utils_1.concat)([
    Uint8Array.from([
        0x14
    ]),
    new Uint8Array(40),
    Uint8Array.from([
        0x14
    ]),
    new Uint8Array(40)
]));
XChainBridge.TYPE_ORDER = [
    {
        name: 'LockingChainDoor',
        type: account_id_1.AccountID
    },
    {
        name: 'LockingChainIssue',
        type: issue_1.Issue
    },
    {
        name: 'IssuingChainDoor',
        type: account_id_1.AccountID
    },
    {
        name: 'IssuingChainIssue',
        type: issue_1.Issue
    }
]; //# sourceMappingURL=xchain-bridge.js.map
}),
"[project]/node_modules/ripple-binary-codec/dist/types/index.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Vector256 = exports.UInt64 = exports.UInt32 = exports.UInt16 = exports.UInt8 = exports.STObject = exports.STArray = exports.PathSet = exports.Hash256 = exports.Hash192 = exports.Hash160 = exports.Hash128 = exports.Currency = exports.Blob = exports.Amount = exports.AccountID = exports.coreTypes = void 0;
const account_id_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/types/account-id.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "AccountID", {
    enumerable: true,
    get: function() {
        return account_id_1.AccountID;
    }
});
const amount_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/types/amount.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "Amount", {
    enumerable: true,
    get: function() {
        return amount_1.Amount;
    }
});
const blob_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/types/blob.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "Blob", {
    enumerable: true,
    get: function() {
        return blob_1.Blob;
    }
});
const currency_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/types/currency.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "Currency", {
    enumerable: true,
    get: function() {
        return currency_1.Currency;
    }
});
const hash_128_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/types/hash-128.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "Hash128", {
    enumerable: true,
    get: function() {
        return hash_128_1.Hash128;
    }
});
const hash_160_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/types/hash-160.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "Hash160", {
    enumerable: true,
    get: function() {
        return hash_160_1.Hash160;
    }
});
const hash_192_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/types/hash-192.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "Hash192", {
    enumerable: true,
    get: function() {
        return hash_192_1.Hash192;
    }
});
const hash_256_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/types/hash-256.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "Hash256", {
    enumerable: true,
    get: function() {
        return hash_256_1.Hash256;
    }
});
const issue_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/types/issue.js [app-ssr] (ecmascript)");
const st_number_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/types/st-number.js [app-ssr] (ecmascript)");
const path_set_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/types/path-set.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "PathSet", {
    enumerable: true,
    get: function() {
        return path_set_1.PathSet;
    }
});
const st_array_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/types/st-array.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "STArray", {
    enumerable: true,
    get: function() {
        return st_array_1.STArray;
    }
});
const st_object_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/types/st-object.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "STObject", {
    enumerable: true,
    get: function() {
        return st_object_1.STObject;
    }
});
const uint_16_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/types/uint-16.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "UInt16", {
    enumerable: true,
    get: function() {
        return uint_16_1.UInt16;
    }
});
const uint_32_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/types/uint-32.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "UInt32", {
    enumerable: true,
    get: function() {
        return uint_32_1.UInt32;
    }
});
const uint_64_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/types/uint-64.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "UInt64", {
    enumerable: true,
    get: function() {
        return uint_64_1.UInt64;
    }
});
const uint_8_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/types/uint-8.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "UInt8", {
    enumerable: true,
    get: function() {
        return uint_8_1.UInt8;
    }
});
const vector_256_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/types/vector-256.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "Vector256", {
    enumerable: true,
    get: function() {
        return vector_256_1.Vector256;
    }
});
const xchain_bridge_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/types/xchain-bridge.js [app-ssr] (ecmascript)");
const enums_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/enums/index.js [app-ssr] (ecmascript)");
const coreTypes = {
    AccountID: account_id_1.AccountID,
    Amount: amount_1.Amount,
    Blob: blob_1.Blob,
    Currency: currency_1.Currency,
    Hash128: hash_128_1.Hash128,
    Hash160: hash_160_1.Hash160,
    Hash192: hash_192_1.Hash192,
    Hash256: hash_256_1.Hash256,
    Issue: issue_1.Issue,
    Number: st_number_1.STNumber,
    PathSet: path_set_1.PathSet,
    STArray: st_array_1.STArray,
    STObject: st_object_1.STObject,
    UInt8: uint_8_1.UInt8,
    UInt16: uint_16_1.UInt16,
    UInt32: uint_32_1.UInt32,
    UInt64: uint_64_1.UInt64,
    Vector256: vector_256_1.Vector256,
    XChainBridge: xchain_bridge_1.XChainBridge
};
exports.coreTypes = coreTypes;
// Ensures that the DEFAULT_DEFINITIONS object connects these types to fields for serializing/deserializing
// This is done here instead of in enums/index.ts to avoid a circular dependency
// because some of the above types depend on BinarySerializer which depends on enums/index.ts.
enums_1.DEFAULT_DEFINITIONS.associateTypes(coreTypes); //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/ripple-binary-codec/dist/hash-prefixes.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.HashPrefix = void 0;
const utils_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/utils.js [app-ssr] (ecmascript)");
/**
 * Write a 32 bit integer to a Uint8Array
 *
 * @param uint32 32 bit integer to write to Uint8Array
 * @returns a Uint8Array with the bytes representation of uint32
 */ function bytes(uint32) {
    const result = new Uint8Array(4);
    (0, utils_1.writeUInt32BE)(result, uint32, 0);
    return result;
}
/**
 * Maps HashPrefix names to their byte representation
 */ const HashPrefix = {
    transactionID: bytes(0x54584e00),
    // transaction plus metadata
    transaction: bytes(0x534e4400),
    // account state
    accountStateEntry: bytes(0x4d4c4e00),
    // inner node in tree
    innerNode: bytes(0x4d494e00),
    // ledger master data for signing
    ledgerHeader: bytes(0x4c575200),
    // inner transaction to sign
    transactionSig: bytes(0x53545800),
    // inner transaction to sign
    transactionMultiSig: bytes(0x534d5400),
    // validation for signing
    validation: bytes(0x56414c00),
    // proposal for signing
    proposal: bytes(0x50525000),
    // payment channel claim
    paymentChannelClaim: bytes(0x434c4d00),
    // batch
    batch: bytes(0x42434800)
};
exports.HashPrefix = HashPrefix; //# sourceMappingURL=hash-prefixes.js.map
}),
"[project]/node_modules/ripple-binary-codec/dist/hashes.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.transactionID = exports.sha512Half = exports.Sha512Half = void 0;
const hash_prefixes_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/hash-prefixes.js [app-ssr] (ecmascript)");
const types_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/types/index.js [app-ssr] (ecmascript)");
const binary_serializer_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/serdes/binary-serializer.js [app-ssr] (ecmascript)");
const sha512_1 = __turbopack_context__.r("[project]/node_modules/@xrplf/isomorphic/dist/sha512/index.js [app-ssr] (ecmascript)");
/**
 * Class for hashing with SHA512
 * @extends BytesList So SerializedTypes can write bytes to a Sha512Half
 */ class Sha512Half extends binary_serializer_1.BytesList {
    constructor(){
        super(...arguments);
        this.hash = sha512_1.sha512.create();
    }
    /**
     * Construct a new Sha512Hash and write bytes this.hash
     *
     * @param bytes bytes to write to this.hash
     * @returns the new Sha512Hash object
     */ static put(bytes) {
        return new Sha512Half().put(bytes);
    }
    /**
     * Write bytes to an existing Sha512Hash
     *
     * @param bytes bytes to write to object
     * @returns the Sha512 object
     */ put(bytes) {
        this.hash.update(bytes);
        return this;
    }
    /**
     * Compute SHA512 hash and slice in half
     *
     * @returns half of a SHA512 hash
     */ finish256() {
        return Uint8Array.from(this.hash.digest().slice(0, 32));
    }
    /**
     * Constructs a Hash256 from the Sha512Half object
     *
     * @returns a Hash256 object
     */ finish() {
        return new types_1.Hash256(this.finish256());
    }
}
exports.Sha512Half = Sha512Half;
/**
 * compute SHA512 hash of a list of bytes
 *
 * @param args zero or more arguments to hash
 * @returns the sha512half hash of the arguments.
 */ function sha512Half(...args) {
    const hash = new Sha512Half();
    args.forEach((a)=>hash.put(a));
    return hash.finish256();
}
exports.sha512Half = sha512Half;
/**
 * Construct a transactionID from a Serialized Transaction
 *
 * @param serialized bytes to hash
 * @returns a Hash256 object
 */ function transactionID(serialized) {
    return new types_1.Hash256(sha512Half(hash_prefixes_1.HashPrefix.transactionID, serialized));
}
exports.transactionID = transactionID; //# sourceMappingURL=hashes.js.map
}),
"[project]/node_modules/ripple-binary-codec/dist/binary.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* eslint-disable func-style */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.signingBatchData = exports.transactionID = exports.sha512Half = exports.binaryToJSON = exports.signingClaimData = exports.signingData = exports.multiSigningData = exports.readJSON = exports.serializeObject = exports.makeParser = exports.BytesList = exports.BinarySerializer = exports.BinaryParser = void 0;
const utils_1 = __turbopack_context__.r("[project]/node_modules/@xrplf/isomorphic/dist/utils/index.js [app-ssr] (ecmascript)");
const types_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/types/index.js [app-ssr] (ecmascript)");
const binary_parser_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/serdes/binary-parser.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "BinaryParser", {
    enumerable: true,
    get: function() {
        return binary_parser_1.BinaryParser;
    }
});
const hash_prefixes_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/hash-prefixes.js [app-ssr] (ecmascript)");
const binary_serializer_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/serdes/binary-serializer.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "BinarySerializer", {
    enumerable: true,
    get: function() {
        return binary_serializer_1.BinarySerializer;
    }
});
Object.defineProperty(exports, "BytesList", {
    enumerable: true,
    get: function() {
        return binary_serializer_1.BytesList;
    }
});
const hashes_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/hashes.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "sha512Half", {
    enumerable: true,
    get: function() {
        return hashes_1.sha512Half;
    }
});
Object.defineProperty(exports, "transactionID", {
    enumerable: true,
    get: function() {
        return hashes_1.transactionID;
    }
});
const enums_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/enums/index.js [app-ssr] (ecmascript)");
/**
 * Construct a BinaryParser
 *
 * @param bytes hex-string or Uint8Array to construct BinaryParser from
 * @param definitions rippled definitions used to parse the values of transaction types and such.
 *                          Can be customized for sidechains and amendments.
 * @returns BinaryParser
 */ const makeParser = (bytes, definitions)=>new binary_parser_1.BinaryParser(bytes instanceof Uint8Array ? (0, utils_1.bytesToHex)(bytes) : bytes, definitions);
exports.makeParser = makeParser;
/**
 * Parse BinaryParser into JSON
 *
 * @param parser BinaryParser object
 * @param definitions rippled definitions used to parse the values of transaction types and such.
 *                          Can be customized for sidechains and amendments.
 * @returns JSON for the bytes in the BinaryParser
 */ const readJSON = (parser, definitions = enums_1.DEFAULT_DEFINITIONS)=>parser.readType(types_1.coreTypes.STObject).toJSON(definitions);
exports.readJSON = readJSON;
/**
 * Parse a hex-string into its JSON interpretation
 *
 * @param bytes hex-string to parse into JSON
 * @param definitions rippled definitions used to parse the values of transaction types and such.
 *                          Can be customized for sidechains and amendments.
 * @returns JSON
 */ const binaryToJSON = (bytes, definitions)=>readJSON(makeParser(bytes, definitions), definitions);
exports.binaryToJSON = binaryToJSON;
/**
 * Function to serialize JSON object representing a transaction
 *
 * @param object JSON object to serialize
 * @param opts options for serializing, including optional prefix, suffix, signingFieldOnly, and definitions
 * @returns A Uint8Array containing the serialized object
 */ function serializeObject(object, opts = {}) {
    const { prefix, suffix, signingFieldsOnly = false, definitions } = opts;
    const bytesList = new binary_serializer_1.BytesList();
    if (prefix) {
        bytesList.put(prefix);
    }
    const filter = signingFieldsOnly ? (f)=>f.isSigningField : undefined;
    types_1.coreTypes.STObject.from(object, filter, definitions).toBytesSink(bytesList);
    if (suffix) {
        bytesList.put(suffix);
    }
    return bytesList.toBytes();
}
exports.serializeObject = serializeObject;
/**
 * Serialize an object for signing
 *
 * @param transaction Transaction to serialize
 * @param prefix Prefix bytes to put before the serialized object
 * @param opts.definitions Custom rippled types to use instead of the default. Used for sidechains and amendments.
 * @returns A Uint8Array with the serialized object
 */ function signingData(transaction, prefix = hash_prefixes_1.HashPrefix.transactionSig, opts = {}) {
    return serializeObject(transaction, {
        prefix,
        signingFieldsOnly: true,
        definitions: opts.definitions
    });
}
exports.signingData = signingData;
/**
 * Serialize a signingClaim
 *
 * @param claim A claim object to serialize
 * @param opts.definitions Custom rippled types to use instead of the default. Used for sidechains and amendments.
 * @returns the serialized object with appropriate prefix
 */ function signingClaimData(claim) {
    const num = BigInt(String(claim.amount));
    const prefix = hash_prefixes_1.HashPrefix.paymentChannelClaim;
    const channel = types_1.coreTypes.Hash256.from(claim.channel).toBytes();
    const amount = types_1.coreTypes.UInt64.from(num).toBytes();
    const bytesList = new binary_serializer_1.BytesList();
    bytesList.put(prefix);
    bytesList.put(channel);
    bytesList.put(amount);
    return bytesList.toBytes();
}
exports.signingClaimData = signingClaimData;
/**
 * Serialize a transaction object for multiSigning
 *
 * @param transaction transaction to serialize
 * @param signingAccount Account to sign the transaction with
 * @param opts.definitions Custom rippled types to use instead of the default. Used for sidechains and amendments.
 * @returns serialized transaction with appropriate prefix and suffix
 */ function multiSigningData(transaction, signingAccount, opts = {
    definitions: enums_1.DEFAULT_DEFINITIONS
}) {
    const prefix = hash_prefixes_1.HashPrefix.transactionMultiSig;
    const suffix = types_1.coreTypes.AccountID.from(signingAccount).toBytes();
    return serializeObject(transaction, {
        prefix,
        suffix,
        signingFieldsOnly: true,
        definitions: opts.definitions
    });
}
exports.multiSigningData = multiSigningData;
/**
 * Serialize a signingClaim
 *
 * @param batch A Batch object to serialize.
 * @returns the serialized object with appropriate prefix
 */ function signingBatchData(batch) {
    if (batch.flags == null) {
        throw Error("No field `flags'");
    }
    if (batch.txIDs == null) {
        throw Error('No field `txIDs`');
    }
    const prefix = hash_prefixes_1.HashPrefix.batch;
    const flags = types_1.coreTypes.UInt32.from(batch.flags).toBytes();
    const txIDsLength = types_1.coreTypes.UInt32.from(batch.txIDs.length).toBytes();
    const bytesList = new binary_serializer_1.BytesList();
    bytesList.put(prefix);
    bytesList.put(flags);
    bytesList.put(txIDsLength);
    batch.txIDs.forEach((txID)=>{
        bytesList.put(types_1.coreTypes.Hash256.from(txID).toBytes());
    });
    return bytesList.toBytes();
}
exports.signingBatchData = signingBatchData; //# sourceMappingURL=binary.js.map
}),
"[project]/node_modules/ripple-binary-codec/dist/shamap.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ShaMapLeaf = exports.ShaMapNode = exports.ShaMap = void 0;
const types_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/types/index.js [app-ssr] (ecmascript)");
const hash_prefixes_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/hash-prefixes.js [app-ssr] (ecmascript)");
const hashes_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/hashes.js [app-ssr] (ecmascript)");
/**
 * Abstract class describing a SHAMapNode
 */ class ShaMapNode {
}
exports.ShaMapNode = ShaMapNode;
/**
 * Class describing a Leaf of SHAMap
 */ class ShaMapLeaf extends ShaMapNode {
    constructor(index, item){
        super();
        this.index = index;
        this.item = item;
    }
    /**
     * @returns true as ShaMapLeaf is a leaf node
     */ isLeaf() {
        return true;
    }
    /**
     * @returns false as ShaMapLeaf is not an inner node
     */ isInner() {
        return false;
    }
    /**
     * Get the prefix of the this.item
     *
     * @returns The hash prefix, unless this.item is undefined, then it returns an empty Uint8Array
     */ hashPrefix() {
        return this.item === undefined ? new Uint8Array(0) : this.item.hashPrefix();
    }
    /**
     * Hash the bytes representation of this
     *
     * @returns hash of this.item concatenated with this.index
     */ hash() {
        const hash = hashes_1.Sha512Half.put(this.hashPrefix());
        this.toBytesSink(hash);
        return hash.finish();
    }
    /**
     * Write the bytes representation of this to a BytesList
     * @param list BytesList to write bytes to
     */ toBytesSink(list) {
        if (this.item !== undefined) {
            this.item.toBytesSink(list);
        }
        this.index.toBytesSink(list);
    }
}
exports.ShaMapLeaf = ShaMapLeaf;
/**
 * Class defining an Inner Node of a SHAMap
 */ class ShaMapInner extends ShaMapNode {
    constructor(depth = 0){
        super();
        this.depth = depth;
        this.slotBits = 0;
        this.branches = Array(16);
    }
    /**
     * @returns true as ShaMapInner is an inner node
     */ isInner() {
        return true;
    }
    /**
     * @returns false as ShaMapInner is not a leaf node
     */ isLeaf() {
        return false;
    }
    /**
     * Get the hash prefix for this node
     *
     * @returns hash prefix describing an inner node
     */ hashPrefix() {
        return hash_prefixes_1.HashPrefix.innerNode;
    }
    /**
     * Set a branch of this node to be another node
     *
     * @param slot Slot to add branch to this.branches
     * @param branch Branch to add
     */ setBranch(slot, branch) {
        this.slotBits = this.slotBits | 1 << slot;
        this.branches[slot] = branch;
    }
    /**
     * @returns true if node is empty
     */ empty() {
        return this.slotBits === 0;
    }
    /**
     * Compute the hash of this node
     *
     * @returns The hash of this node
     */ hash() {
        if (this.empty()) {
            return types_1.coreTypes.Hash256.ZERO_256;
        }
        const hash = hashes_1.Sha512Half.put(this.hashPrefix());
        this.toBytesSink(hash);
        return hash.finish();
    }
    /**
     * Writes the bytes representation of this node to a BytesList
     *
     * @param list BytesList to write bytes to
     */ toBytesSink(list) {
        for(let i = 0; i < this.branches.length; i++){
            const branch = this.branches[i];
            const hash = branch ? branch.hash() : types_1.coreTypes.Hash256.ZERO_256;
            hash.toBytesSink(list);
        }
    }
    /**
     * Add item to the SHAMap
     *
     * @param index Hash of the index of the item being inserted
     * @param item Item to insert in the map
     * @param leaf Leaf node to insert when branch doesn't exist
     */ addItem(index, item, leaf) {
        if (index === undefined) {
            throw new Error();
        }
        if (index !== undefined) {
            const nibble = index.nibblet(this.depth);
            const existing = this.branches[nibble];
            if (existing === undefined) {
                this.setBranch(nibble, leaf || new ShaMapLeaf(index, item));
            } else if (existing instanceof ShaMapLeaf) {
                const newInner = new ShaMapInner(this.depth + 1);
                newInner.addItem(existing.index, undefined, existing);
                newInner.addItem(index, item, leaf);
                this.setBranch(nibble, newInner);
            } else if (existing instanceof ShaMapInner) {
                existing.addItem(index, item, leaf);
            } else {
                throw new Error('invalid ShaMap.addItem call');
            }
        }
    }
}
class ShaMap extends ShaMapInner {
}
exports.ShaMap = ShaMap; //# sourceMappingURL=shamap.js.map
}),
"[project]/node_modules/ripple-binary-codec/dist/ledger-hashes.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.decodeLedgerData = exports.ledgerHash = exports.transactionTreeHash = exports.accountStateHash = void 0;
const shamap_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/shamap.js [app-ssr] (ecmascript)");
const hash_prefixes_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/hash-prefixes.js [app-ssr] (ecmascript)");
const hashes_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/hashes.js [app-ssr] (ecmascript)");
const binary_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/binary.js [app-ssr] (ecmascript)");
const hash_256_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/types/hash-256.js [app-ssr] (ecmascript)");
const st_object_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/types/st-object.js [app-ssr] (ecmascript)");
const uint_64_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/types/uint-64.js [app-ssr] (ecmascript)");
const uint_32_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/types/uint-32.js [app-ssr] (ecmascript)");
const uint_8_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/types/uint-8.js [app-ssr] (ecmascript)");
const binary_parser_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/serdes/binary-parser.js [app-ssr] (ecmascript)");
/**
 * Computes the hash of a list of objects
 *
 * @param itemizer Converts an item into a format that can be added to SHAMap
 * @param itemsJson Array of items to add to a SHAMap
 * @returns the hash of the SHAMap
 */ function computeHash(itemizer, itemsJson) {
    const map = new shamap_1.ShaMap();
    itemsJson.forEach((item)=>map.addItem(...itemizer(item)));
    return map.hash();
}
/**
 * Convert a transaction into an index and an item
 *
 * @param json transaction with metadata
 * @returns a tuple of index and item to be added to SHAMap
 */ function transactionItemizer(json) {
    if (!json.hash) {
        throw new Error();
    }
    const index = hash_256_1.Hash256.from(json.hash);
    const item = {
        hashPrefix () {
            return hash_prefixes_1.HashPrefix.transaction;
        },
        toBytesSink (sink) {
            const serializer = new binary_1.BinarySerializer(sink);
            serializer.writeLengthEncoded(st_object_1.STObject.from(json));
            serializer.writeLengthEncoded(st_object_1.STObject.from(json.metaData));
        }
    };
    return [
        index,
        item,
        undefined
    ];
}
/**
 * Convert an entry to a pair Hash256 and ShaMapNode
 *
 * @param json JSON describing a ledger entry item
 * @returns a tuple of index and item to be added to SHAMap
 */ function entryItemizer(json) {
    const index = hash_256_1.Hash256.from(json.index);
    const bytes = (0, binary_1.serializeObject)(json);
    const item = {
        hashPrefix () {
            return hash_prefixes_1.HashPrefix.accountStateEntry;
        },
        toBytesSink (sink) {
            sink.put(bytes);
        }
    };
    return [
        index,
        item,
        undefined
    ];
}
/**
 * Function computing the hash of a transaction tree
 *
 * @param param An array of transaction objects to hash
 * @returns A Hash256 object
 */ function transactionTreeHash(param) {
    const itemizer = transactionItemizer;
    return computeHash(itemizer, param);
}
exports.transactionTreeHash = transactionTreeHash;
/**
 * Function computing the hash of accountState
 *
 * @param param A list of accountStates hash
 * @returns A Hash256 object
 */ function accountStateHash(param) {
    const itemizer = entryItemizer;
    return computeHash(itemizer, param);
}
exports.accountStateHash = accountStateHash;
/**
 * Serialize and hash a ledger header
 *
 * @param header a ledger header
 * @returns the hash of header
 */ function ledgerHash(header) {
    const hash = new hashes_1.Sha512Half();
    hash.put(hash_prefixes_1.HashPrefix.ledgerHeader);
    if (header.parent_close_time === undefined || header.close_flags === undefined) {
        throw new Error();
    }
    uint_32_1.UInt32.from(header.ledger_index).toBytesSink(hash);
    uint_64_1.UInt64.from(BigInt(String(header.total_coins))).toBytesSink(hash);
    hash_256_1.Hash256.from(header.parent_hash).toBytesSink(hash);
    hash_256_1.Hash256.from(header.transaction_hash).toBytesSink(hash);
    hash_256_1.Hash256.from(header.account_hash).toBytesSink(hash);
    uint_32_1.UInt32.from(header.parent_close_time).toBytesSink(hash);
    uint_32_1.UInt32.from(header.close_time).toBytesSink(hash);
    uint_8_1.UInt8.from(header.close_time_resolution).toBytesSink(hash);
    uint_8_1.UInt8.from(header.close_flags).toBytesSink(hash);
    return hash.finish();
}
exports.ledgerHash = ledgerHash;
/**
 * Decodes a serialized ledger header
 *
 * @param binary A serialized ledger header
 * @param definitions Type definitions to parse the ledger objects.
 *      Used if there are non-default ledger objects to decode.
 * @returns A JSON object describing a ledger header
 */ function decodeLedgerData(binary, definitions) {
    if (typeof binary !== 'string') {
        throw new Error('binary must be a hex string');
    }
    const parser = new binary_parser_1.BinaryParser(binary, definitions);
    return {
        ledger_index: parser.readUInt32(),
        total_coins: parser.readType(uint_64_1.UInt64).valueOf().toString(),
        parent_hash: parser.readType(hash_256_1.Hash256).toHex(),
        transaction_hash: parser.readType(hash_256_1.Hash256).toHex(),
        account_hash: parser.readType(hash_256_1.Hash256).toHex(),
        parent_close_time: parser.readUInt32(),
        close_time: parser.readUInt32(),
        close_time_resolution: parser.readUInt8(),
        close_flags: parser.readUInt8()
    };
}
exports.decodeLedgerData = decodeLedgerData; //# sourceMappingURL=ledger-hashes.js.map
}),
"[project]/node_modules/ripple-binary-codec/dist/quality.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.quality = void 0;
const types_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/types/index.js [app-ssr] (ecmascript)");
const bignumber_js_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/bignumber.js/bignumber.js [app-ssr] (ecmascript)"));
const utils_1 = __turbopack_context__.r("[project]/node_modules/@xrplf/isomorphic/dist/utils/index.js [app-ssr] (ecmascript)");
/**
 * class for encoding and decoding quality
 */ class quality {
    /**
     * Encode quality amount
     *
     * @param arg string representation of an amount
     * @returns Serialized quality
     */ static encode(quality) {
        const decimal = (0, bignumber_js_1.default)(quality);
        const exponent = ((decimal === null || decimal === void 0 ? void 0 : decimal.e) || 0) - 15;
        const qualityString = decimal.times(`1e${-exponent}`).abs().toString();
        const bytes = types_1.coreTypes.UInt64.from(BigInt(qualityString)).toBytes();
        bytes[0] = exponent + 100;
        return bytes;
    }
    /**
     * Decode quality amount
     *
     * @param arg hex-string denoting serialized quality
     * @returns deserialized quality
     */ static decode(quality) {
        const bytes = (0, utils_1.hexToBytes)(quality).slice(-8);
        const exponent = bytes[0] - 100;
        const mantissa = new bignumber_js_1.default(`0x${(0, utils_1.bytesToHex)(bytes.slice(1))}`);
        return mantissa.times(`1e${exponent}`);
    }
}
exports.quality = quality; //# sourceMappingURL=quality.js.map
}),
"[project]/node_modules/ripple-binary-codec/dist/coretypes.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.types = exports.ShaMap = exports.HashPrefix = exports.quality = exports.TransactionResult = exports.Type = exports.LedgerEntryType = exports.TransactionType = exports.Field = exports.DEFAULT_DEFINITIONS = exports.ledgerHashes = exports.binary = exports.hashes = void 0;
const enums_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/enums/index.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "DEFAULT_DEFINITIONS", {
    enumerable: true,
    get: function() {
        return enums_1.DEFAULT_DEFINITIONS;
    }
});
Object.defineProperty(exports, "Field", {
    enumerable: true,
    get: function() {
        return enums_1.Field;
    }
});
Object.defineProperty(exports, "TransactionType", {
    enumerable: true,
    get: function() {
        return enums_1.TransactionType;
    }
});
Object.defineProperty(exports, "LedgerEntryType", {
    enumerable: true,
    get: function() {
        return enums_1.LedgerEntryType;
    }
});
Object.defineProperty(exports, "Type", {
    enumerable: true,
    get: function() {
        return enums_1.Type;
    }
});
Object.defineProperty(exports, "TransactionResult", {
    enumerable: true,
    get: function() {
        return enums_1.TransactionResult;
    }
});
const types = __importStar(__turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/types/index.js [app-ssr] (ecmascript)"));
exports.types = types;
const binary = __importStar(__turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/binary.js [app-ssr] (ecmascript)"));
exports.binary = binary;
const shamap_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/shamap.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "ShaMap", {
    enumerable: true,
    get: function() {
        return shamap_1.ShaMap;
    }
});
const ledgerHashes = __importStar(__turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/ledger-hashes.js [app-ssr] (ecmascript)"));
exports.ledgerHashes = ledgerHashes;
const hashes = __importStar(__turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/hashes.js [app-ssr] (ecmascript)"));
exports.hashes = hashes;
const quality_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/quality.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "quality", {
    enumerable: true,
    get: function() {
        return quality_1.quality;
    }
});
const hash_prefixes_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/hash-prefixes.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "HashPrefix", {
    enumerable: true,
    get: function() {
        return hash_prefixes_1.HashPrefix;
    }
}); //# sourceMappingURL=coretypes.js.map
}),
"[project]/node_modules/ripple-binary-codec/dist/enums/xrpl-definitions.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.XrplDefinitions = void 0;
const xrpl_definitions_base_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/enums/xrpl-definitions-base.js [app-ssr] (ecmascript)");
const types_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/types/index.js [app-ssr] (ecmascript)");
/**
 * Stores the various types and fields for rippled to be used to encode/decode information later on.
 * Should be used instead of XrplDefinitionsBase since this defines default `types` for serializing/deserializing
 * ledger data.
 */ class XrplDefinitions extends xrpl_definitions_base_1.XrplDefinitionsBase {
    /**
     * Present rippled types in a typed and updatable format.
     * For an example of the input format see `definitions.json`
     * To generate a new definitions file from rippled source code, use the tool at
     * `packages/ripple-binary-codec/tools/generateDefinitions.js`.
     *
     * See the definitions.test.js file for examples of how to create your own updated definitions.json.
     *
     * @param enums - A json encoding of the core types, transaction types, transaction results, transaction names, and fields.
     * @param additionalTypes - A list of SerializedType objects with the same name as the fields defined.
     *              These types will be included in addition to the coreTypes used on mainnet.
     */ constructor(enums, additionalTypes){
        const types = Object.assign({}, types_1.coreTypes, additionalTypes);
        super(enums, types);
    }
}
exports.XrplDefinitions = XrplDefinitions; //# sourceMappingURL=xrpl-definitions.js.map
}),
"[project]/node_modules/ripple-binary-codec/dist/index.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.coreTypes = exports.DEFAULT_DEFINITIONS = exports.XrplDefinitionsBase = exports.XrplDefinitions = exports.TRANSACTION_TYPES = exports.decodeLedgerData = exports.decodeQuality = exports.encodeQuality = exports.encodeForSigningBatch = exports.encodeForMultisigning = exports.encodeForSigningClaim = exports.encodeForSigning = exports.encode = exports.decode = void 0;
const coretypes_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/coretypes.js [app-ssr] (ecmascript)");
const ledger_hashes_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/ledger-hashes.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "decodeLedgerData", {
    enumerable: true,
    get: function() {
        return ledger_hashes_1.decodeLedgerData;
    }
});
const enums_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/enums/index.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "XrplDefinitionsBase", {
    enumerable: true,
    get: function() {
        return enums_1.XrplDefinitionsBase;
    }
});
Object.defineProperty(exports, "TRANSACTION_TYPES", {
    enumerable: true,
    get: function() {
        return enums_1.TRANSACTION_TYPES;
    }
});
Object.defineProperty(exports, "DEFAULT_DEFINITIONS", {
    enumerable: true,
    get: function() {
        return enums_1.DEFAULT_DEFINITIONS;
    }
});
const xrpl_definitions_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/enums/xrpl-definitions.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "XrplDefinitions", {
    enumerable: true,
    get: function() {
        return xrpl_definitions_1.XrplDefinitions;
    }
});
const types_1 = __turbopack_context__.r("[project]/node_modules/ripple-binary-codec/dist/types/index.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "coreTypes", {
    enumerable: true,
    get: function() {
        return types_1.coreTypes;
    }
});
const utils_1 = __turbopack_context__.r("[project]/node_modules/@xrplf/isomorphic/dist/utils/index.js [app-ssr] (ecmascript)");
const { signingData, signingClaimData, multiSigningData, signingBatchData, binaryToJSON, serializeObject } = coretypes_1.binary;
/**
 * Decode a transaction
 *
 * @param binary hex-string of the encoded transaction
 * @param definitions Custom rippled types to use instead of the default. Used for sidechains and amendments.
 * @returns the JSON representation of the transaction
 */ function decode(binary, definitions) {
    if (typeof binary !== 'string') {
        throw new Error('binary must be a hex string');
    }
    return binaryToJSON(binary, definitions);
}
exports.decode = decode;
/**
 * Encode a transaction
 *
 * @param json The JSON representation of a transaction
 * @param definitions Custom rippled types to use instead of the default. Used for sidechains and amendments.
 *
 * @returns A hex-string of the encoded transaction
 */ function encode(json, definitions) {
    if (typeof json !== 'object') {
        throw new Error();
    }
    return (0, utils_1.bytesToHex)(serializeObject(json, {
        definitions
    }));
}
exports.encode = encode;
/**
 * Encode a transaction and prepare for signing
 *
 * @param json JSON object representing the transaction
 * @param signer string representing the account to sign the transaction with
 * @param definitions Custom rippled types to use instead of the default. Used for sidechains and amendments.
 * @returns a hex string of the encoded transaction
 */ function encodeForSigning(json, definitions) {
    if (typeof json !== 'object') {
        throw new Error();
    }
    return (0, utils_1.bytesToHex)(signingData(json, coretypes_1.HashPrefix.transactionSig, {
        definitions
    }));
}
exports.encodeForSigning = encodeForSigning;
/**
 * Encode a payment channel claim for signing.
 *
 * @param json JSON object representing the claim.
 * @returns a hex string of the encoded claim.
 */ function encodeForSigningClaim(json) {
    if (typeof json !== 'object') {
        throw new Error();
    }
    return (0, utils_1.bytesToHex)(signingClaimData(json));
}
exports.encodeForSigningClaim = encodeForSigningClaim;
/**
 * Encode a transaction and prepare for multi-signing.
 *
 * @param json JSON object representing the transaction.
 * @param signer string representing the account to sign the transaction with.
 * @param definitions Custom rippled types to use instead of the default. Used for sidechains and amendments.
 * @returns a hex string of the encoded transaction.
 */ function encodeForMultisigning(json, signer, definitions) {
    if (typeof json !== 'object') {
        throw new Error();
    }
    const definitionsOpt = definitions ? {
        definitions
    } : undefined;
    return (0, utils_1.bytesToHex)(multiSigningData(json, signer, definitionsOpt));
}
exports.encodeForMultisigning = encodeForMultisigning;
/**
 * Encode a Batch transaction for signing.
 *
 * @param json JSON object representing the transaction.
 * @returns a hex string of the encoded transaction.
 */ function encodeForSigningBatch(json) {
    if (typeof json !== 'object') {
        throw new Error('Need an object to encode a Batch transaction');
    }
    return (0, utils_1.bytesToHex)(signingBatchData(json));
}
exports.encodeForSigningBatch = encodeForSigningBatch;
/**
 * Encode a quality value
 *
 * @param value string representation of a number
 * @returns a hex-string representing the quality
 */ function encodeQuality(value) {
    if (typeof value !== 'string') {
        throw new Error();
    }
    return (0, utils_1.bytesToHex)(coretypes_1.quality.encode(value));
}
exports.encodeQuality = encodeQuality;
/**
 * Decode a quality value
 *
 * @param value hex-string of a quality
 * @returns a string representing the quality
 */ function decodeQuality(value) {
    if (typeof value !== 'string') {
        throw new Error();
    }
    return coretypes_1.quality.decode(value).toString();
}
exports.decodeQuality = decodeQuality; //# sourceMappingURL=index.js.map
}),
];

//# sourceMappingURL=node_modules_ripple-binary-codec_dist_a87d7ac1._.js.map